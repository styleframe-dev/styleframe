---
title: Breakpoints
description: Create and manage responsive breakpoint design tokens with CSS variables for consistent media query handling and adaptive layouts across your application.
---

## Overview

The breakpoint composable helps you create consistent responsive design systems with minimal code. It generates breakpoint variables that can be easily referenced in media queries throughout your application, enabling flexible theming and consistent responsive behavior across different screen sizes.

## Why use breakpoint composables?

Breakpoint composables help you:

- **Centralize breakpoint values**: Define all your responsive breakpoints in one place for easy management.
- **Enable flexible theming**: Override breakpoint values to instantly adjust responsive behavior across your application.
- **Maintain consistency**: Use semantic names to ensure consistent breakpoint usage throughout your design system.
- **Simplify media queries**: Reference breakpoint variables instead of hard-coding pixel values in every media query.

## `useBreakpoint`

The `useBreakpoint()` function creates a set of breakpoint variables from a simple object of breakpoint value definitions.

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBreakpoint } from '@styleframe/theme';

const s = styleframe();

/**
 * Use default breakpoint values
 * {
 *   xs: 0,
 *   sm: 576,
 *   md: 992,
 *   lg: 1200,
 *   xl: 1440,
 * }
 */
const {
    breakpointXs,
    breakpointSm,
    breakpointMd,
    breakpointLg,
    breakpointXl,
} = useBreakpoint(s);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint--xs: 0;
    --breakpoint--sm: 576;
    --breakpoint--md: 992;
    --breakpoint--lg: 1200;
    --breakpoint--xl: 1440;
}
```

:::
::

Each key in the object becomes a breakpoint variable with the prefix `breakpoint--`, and the export name is automatically converted to camelCase (e.g., `xs` → `breakpointXs`, `md` → `breakpointMd`).

::tip

**Pro tip:** Use semantic names like `xs`, `sm`, `md`, `lg`, and `xl` to create a consistent responsive system that's easy to understand and maintain across your application.

::

### Creating Custom Breakpoint Variables

You can provide your own custom breakpoint values to match your design system's needs.

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBreakpoint } from '@styleframe/theme';

const s = styleframe();

const {
    breakpointMobile,
    breakpointTablet,
    breakpointLaptop,
    breakpointDesktop,
} = useBreakpoint(s, {
    mobile: 320,
    tablet: 768,
    laptop: 1024,
    desktop: 1440,
} as const);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint--mobile: 320;
    --breakpoint--tablet: 768;
    --breakpoint--laptop: 1024;
    --breakpoint--desktop: 1440;
}
```

:::
::

### Extending the Default Breakpoint Variables

Styleframe provides default breakpoint values that you can import and use directly, so you don't have to manually define common breakpoint scales:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBreakpoint, defaultBreakpointValues } from '@styleframe/theme';

const s = styleframe();

/**
 * Use default breakpoint values
 * {
 *   xs: 0,
 *   sm: 576,
 *   md: 992,
 *   lg: 1200,
 *   xl: 1440,
 * }
 */
const {
    breakpointXs,
    breakpointSm,
    breakpointMd,
    breakpointLg,
    breakpointXl,
} = useBreakpoint(s, {
    ...defaultBreakpointValues,
    '2xl': 1920,
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint--xs: 0;
    --breakpoint--sm: 576;
    --breakpoint--md: 992;
    --breakpoint--lg: 1200;
    --breakpoint--xl: 1440;
    --breakpoint--2xl: 1920;
}
```

:::
::

Using these defaults ensures consistency across your project and reduces boilerplate code. You can always override them by passing your own custom values when needed.


## Using Breakpoint Variables in Media Queries

Once created, breakpoint variables can be used in media queries throughout your styles:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBreakpoint } from '@styleframe/theme';

const s = styleframe();
const { ref, selector, media } = s;

const { breakpointSm, breakpointMd, breakpointLg } = useBreakpoint(s, {
    sm: 576,
    md: 992,
    lg: 1200,
} as const);

selector('.container', {
    width: '100%',
    padding: '1rem',
});

// Tablet and up
media(`screen and (min-width: ${breakpointMd.value}px)`, () => {
    selector('.container', {
        maxWidth: '960px',
        margin: '0 auto',
    });
});

// Desktop and up
media(`screen and (min-width: ${breakpointLg.value}px)`, () => {
    selector('.container', {
        maxWidth: '1140px',
    });
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint--sm: 576;
    --breakpoint--md: 992;
    --breakpoint--lg: 1200;
}

.container {
    width: 100%;
    padding: 1rem;
}

@media (min-width: 992px) {
    .container {
        max-width: 960px;
        margin: 0 auto;
    }
}

@media (min-width: 1200px) {
    .container {
        max-width: 1140px;
    }
}
```

:::
::



::caution

**Important:** We reference breakpoint values in media queries because CSS does not support referencing variables in media queries yet.

::

## Examples

### Range-Based Media Queries

Use breakpoints to create range-based media queries for specific viewport sizes:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBreakpoint, defaultBreakpointValues } from '@styleframe/theme';

const s = styleframe();
const { ref, selector, media } = s;

const { breakpointSm, breakpointMd, breakpointLg } = 
    useBreakpoint(s, defaultBreakpointValues);

selector('.sidebar', {
    display: 'none',
});

// Show sidebar only on tablets (between sm and lg)
media({ 
    minWidth: ref(breakpointSm), 
    maxWidth: ref(breakpointLg) 
}, () => {
    selector('.sidebar', {
        display: 'block',
        width: '250px',
    });
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint--sm: 576;
    --breakpoint--md: 992;
    --breakpoint--lg: 1200;
}

.sidebar {
    display: none;
}

@media (min-width: 576px) and (max-width: 1200px) {
    .sidebar {
        display: block;
        width: 250px;
    }
}
```

:::
::

### Custom Breakpoint Scale

Create a custom breakpoint scale tailored to your specific design needs:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBreakpoint } from '@styleframe/theme';

const s = styleframe();
const { ref, selector, media } = s;

// Custom breakpoints for a specific application
const {
    breakpointMobile,
    breakpointTablet,
    breakpointDesktop,
    breakpointWide,
    breakpointUltrawide,
} = useBreakpoint(s, {
    mobile: 0,
    tablet: 768,
    desktop: 1024,
    wide: 1920,
    ultrawide: 2560,
} as const);

selector('.hero', {
    minHeight: '400px',
    fontSize: '1.5rem',
});

media(`screen and (min-width: ${breakpointTablet.value}px)`, () => {
    selector('.hero', {
        minHeight: '500px',
        fontSize: '2rem',
    });
});

media(`screen and (min-width: ${breakpointDesktop.value}px)`, () => {
    selector('.hero', {
        minHeight: '600px',
        fontSize: '2.5rem',
    });
});

media(`screen and (min-width: ${breakpointWide.value}px)`, () => {
    selector('.hero', {
        minHeight: '800px',
        fontSize: '3rem',
    });
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint--mobile: 0;
    --breakpoint--tablet: 768;
    --breakpoint--desktop: 1024;
    --breakpoint--wide: 1920;
    --breakpoint--ultrawide: 2560;
}

.hero {
    min-height: 400px;
    font-size: 1.5rem;
}

@media (min-width: 768px) {
    .hero {
        min-height: 500px;
        font-size: 2rem;
    }
}

@media (min-width: 1024px) {
    .hero {
        min-height: 600px;
        font-size: 2.5rem;
    }
}

@media (min-width: 1920px) {
    .hero {
        min-height: 800px;
        font-size: 3rem;
    }
}
```

:::
::

## Best Practices

- **Use mobile-first approach**: Start with mobile styles and progressively enhance for larger screens using `min-width` media queries.
- **Keep breakpoints consistent**: Limit your breakpoints to 4-6 key sizes. Too many breakpoints make maintenance difficult.
- **Choose meaningful values**: Use semantic values that reflect device categories or layout changes rather than arbitrary sizes.
- **Avoid device-specific breakpoints**: Design for content, not specific devices. Breakpoints should be based on when your layout needs to adapt.
- **Test between breakpoints**: Ensure your design works at all viewport sizes, not just at the exact breakpoint values.
- **Consider orientation**: For mobile devices, you may want separate breakpoints for portrait and landscape orientations.
- **Document your breakpoint strategy**: Make it clear when and why each breakpoint should be used in your design system.

::note

**Good to know:** We use `as const` to ensure the object is treated as a constant type. This helps TypeScript infer the return type of the composables and provides better type safety and autocomplete support.

::

## FAQ

::accordion

:::accordion-item{label="What breakpoint values should I use?" icon="i-lucide-circle-help"}
There's no one-size-fits-all answer. The default values (0, 576, 992, 1200, 1440) are based on common device sizes, but you should choose breakpoints based on when your content needs to adapt. Start with your design and add breakpoints where the layout naturally needs to change.
:::

:::accordion-item{label="Should I use mobile-first or desktop-first?" icon="i-lucide-circle-help"}
Mobile-first is generally recommended. It encourages progressive enhancement, results in simpler CSS, and aligns with the reality that mobile traffic often exceeds desktop traffic. Start with mobile styles and use `min-width` media queries to enhance for larger screens.
:::

:::accordion-item{label="How many breakpoints should I have?" icon="i-lucide-circle-help"}
Aim for 4-6 breakpoints in most cases. Common patterns include: mobile (0), tablet (600-768), desktop (992-1024), and large desktop (1200-1440). Add more only if your design truly needs them. Too many breakpoints increase complexity and maintenance burden.
:::

:::accordion-item{label="Should I use pixels, ems, or rems for breakpoints?" icon="i-lucide-circle-help"}
This is debated, but pixels are commonly used and work well for most cases. Some developers prefer ems/rems because they respect user font size preferences in media queries. However, modern browsers handle media queries consistently, so choose what makes sense for your project and team.
:::

:::accordion-item{label="Can I change breakpoints at runtime?" icon="i-lucide-circle-help"}
The breakpoint variables themselves can be changed at runtime by overriding the CSS custom properties. However, media queries are evaluated by the browser based on the actual viewport size, so changing the CSS variable won't affect when media queries trigger. The variables are mainly useful for referencing consistent values throughout your styles.
:::

:::accordion-item{label="Should I define breakpoints in pixels or unitless numbers?" icon="i-lucide-circle-help"}
In `useBreakpoint()`, define them as unitless numbers (like `992` instead of `'992px'`). This keeps your breakpoint definitions clean and makes them easier to work with in calculations.
:::

:::accordion-item{label="What's the difference between breakpoint variables and hard-coded values?" icon="i-lucide-circle-help"}
Breakpoint variables provide a single source of truth, making it easy to adjust your responsive design system globally. They also make your media queries more semantic and self-documenting. Hard-coded values are scattered throughout your codebase and harder to maintain consistently.
:::

::
