---
title: Borders
description: Create and manage border design tokens with CSS variables for consistent border styles, widths, and colors across your application.
---

## Overview

The border composables help you create comprehensive border systems with minimal code. They generate border-related variables that can be easily referenced throughout your application, enabling flexible theming and consistent visual boundaries for your components.

## Why use border composables?

Border composables help you:

- **Centralize border definitions**: Define all your border styles, widths, and colors in one place for easy management.
- **Enable flexible theming**: Override border variables to instantly update component borders across your application.
- **Maintain consistency**: Use semantic names to ensure consistent border usage throughout your design system.
- **Reduce repetition**: Reference border variables instead of repeating CSS values throughout your stylesheets.
- **Separate concerns**: Keep border colors semantically distinct from other color usage in your application.

## `useBorderStyle`

The `useBorderStyle()` function creates a set of border style variables covering all standard CSS border styles.

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderStyle } from 'styleframe/theme';

const s = styleframe();

const {
    borderStyle,
    borderStyleNone,
    borderStyleSolid,
    borderStyleDashed,
    borderStyleDotted,
    borderStyleDouble,
    borderStyleGroove,
    borderStyleInset,
    borderStyleOutset,
} = useBorderStyle(s);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-style--none: none;
    --border-style--solid: solid;
    --border-style--dashed: dashed;
    --border-style--dotted: dotted;
    --border-style--double: double;
    --border-style--groove: groove;
    --border-style--inset: inset;
    --border-style--outset: outset;
    --border-style: var(--border-style--solid);
}
```

:::
::

The function creates variables for all standard CSS border styles and a default `--border-style` variable that references `solid` by default.

### Customizing the Default Style

You can customize which style is used as the default:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderStyle } from 'styleframe/theme';

const s = styleframe();

const { borderStyle } = useBorderStyle(s, 'dashed');

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-style--none: none;
    --border-style--solid: solid;
    --border-style--dashed: dashed;
    --border-style--dotted: dotted;
    --border-style--double: double;
    --border-style--groove: groove;
    --border-style--inset: inset;
    --border-style--outset: outset;
    --border-style: var(--border-style--dashed);
}
```

:::
::

::tip

**Pro tip:** Using a default `--border-style` variable makes it easy to change your entire application's border style by overriding just one variable, while still having specific style variants available when needed.

::

## `useBorderWidth`

The `useBorderWidth()` function creates a set of border width variables for common border thickness levels.

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderWidth } from 'styleframe/theme';

const s = styleframe();

const {
    borderWidth,
    borderWidthNone,
    borderWidthThin,
    borderWidthMedium,
    borderWidthThick,
} = useBorderWidth(s);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-width--none: 0;
    --border-width--thin: thin;
    --border-width--medium: medium;
    --border-width--thick: thick;
    --border-width: var(--border-width--thin);
}
```

:::
::

The function creates variables for standard CSS border widths including `none` (0), `thin`, `medium`, and `thick`. The default `--border-width` variable references `thin` by default.

::note

**Good to know:** CSS defines `thin`, `medium`, and `thick` as keyword values that browsers interpret consistently. Typically, `thin` is 1px, `medium` is 3px, and `thick` is 5px, but this can vary slightly by browser.

::

### Customizing the Default Width

You can customize which width is used as the default:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderWidth } from 'styleframe/theme';

const s = styleframe();

const { borderWidth } = useBorderWidth(s, 'medium');

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-width--none: 0;
    --border-width--thin: thin;
    --border-width--medium: medium;
    --border-width--thick: thick;
    --border-width: var(--border-width--medium);
}
```

:::
::

### Custom Border Width Values

While the composable uses CSS keyword values by default, you can extend it with custom widths using the core Styleframe API:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderWidth } from 'styleframe/theme';

const s = styleframe();

const { borderWidth } = useBorderWidth(s);

// Add custom border widths
const borderWidthHairline = s.variable('border-width--hairline', '0.5px', {
    default: true,
});

const borderWidthBold = s.variable('border-width--bold', '4px', {
    default: true,
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-width--none: 0;
    --border-width--thin: thin;
    --border-width--medium: medium;
    --border-width--thick: thick;
    --border-width: var(--border-width--thin);
    --border-width--hairline: 0.5px;
    --border-width--bold: 4px;
}
```

:::
::

## `useBorderColor`

The `useBorderColor()` function creates a set of border color variables that reference your base color system. This provides semantic separation between general colors and colors specifically intended for borders.

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useColor, useBorderColor } from 'styleframe/theme';

const s = styleframe();
const { ref } = s;

// Define base colors
const { colorGray, colorPrimary, colorSuccess, colorDanger } = useColor(s, {
    gray: '#6b7280',
    primary: '#3b82f6',
    success: '#10b981',
    danger: '#ef4444',
} as const);

// Create border color variables
const {
    borderColor,
    borderColorPrimary,
    borderColorSuccess,
    borderColorDanger,
} = useBorderColor(s, {
    default: ref(colorGray),
    primary: ref(colorPrimary),
    success: ref(colorSuccess),
    danger: ref(colorDanger),
} as const);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --color--gray: oklch(0.5575 0.0165 244.89 / 1);
    --color--primary: oklch(0.6109 0.1903 263.71 / 1);
    --color--success: oklch(0.7051 0.1654 165.47 / 1);
    --color--danger: oklch(0.6278 0.2158 27.33 / 1);
    --border-color: var(--color--gray);
    --border-color--primary: var(--color--primary);
    --border-color--success: var(--color--success);
    --border-color--danger: var(--color--danger);
}
```

:::
::

Each key in the object becomes a border color variable with the prefix `border-color--`, and the export name is automatically converted to camelCase (e.g., `default` → `borderColor`, `primary` → `borderColorPrimary`).

::tip

**Pro tip:** Using `useBorderColor()` instead of directly referencing color variables makes your intent explicit and allows you to easily adjust border colors independently from your base color palette. For example, you might want borders to be lighter or more desaturated than the base colors.

::

### Creating Border Color Variants

You can combine `useBorderColor()` with color manipulation composables to create sophisticated border color systems:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useColor, useColorLightness, useBorderColor } from 'styleframe/theme';

const s = styleframe();
const { ref } = s;

// Base color
const { colorGray } = useColor(s, { gray: '#6b7280' } as const);

// Create lightness variants
const { colorGray300, colorGray500, colorGray700 } = useColorLightness(s, colorGray, {
    300: 82,
    500: 55,
    700: 35,
} as const);

// Create semantic border colors
const {
    borderColor,
    borderColorLight,
    borderColorDark,
} = useBorderColor(s, {
    default: ref(colorGray500),
    light: ref(colorGray300),
    dark: ref(colorGray700),
} as const);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --color--gray: oklch(0.5575 0.0165 244.89 / 1);
    --color--gray-300: oklch(from var(--color--gray) 0.82 c h / a);
    --color--gray-500: oklch(from var(--color--gray) 0.55 c h / a);
    --color--gray-700: oklch(from var(--color--gray) 0.35 c h / a);
    --border-color: var(--color--gray-500);
    --border-color--light: var(--color--gray-300);
    --border-color--dark: var(--color--gray-700);
}
```

:::
::

## Complete Border System

Here's how to combine all three border composables to create a comprehensive border system:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderStyle, useBorderWidth, useColor, useBorderColor } from 'styleframe/theme';

const s = styleframe();
const { ref, selector, css } = s;

// Setup border styles and widths
const { borderStyle, borderStyleDashed } = useBorderStyle(s);
const { borderWidth, borderWidthMedium } = useBorderWidth(s);

// Setup base colors
const { colorGray, colorPrimary, colorSuccess, colorWarning, colorDanger } = useColor(s, {
    gray: '#d1d5db',
    primary: '#3b82f6',
    success: '#10b981',
    warning: '#f59e0b',
    danger: '#ef4444',
} as const);

// Setup border colors
const {
    borderColor,
    borderColorPrimary,
    borderColorSuccess,
    borderColorWarning,
    borderColorDanger,
} = useBorderColor(s, {
    default: ref(colorGray),
    primary: ref(colorPrimary),
    success: ref(colorSuccess),
    warning: ref(colorWarning),
    danger: ref(colorDanger),
} as const);

// Use border variables in components
selector('.card', {
    border: css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColor)}`,
});

selector('.input', {
    border: css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColor)}`,
    '&:focus': {
        borderColor: ref(borderColorPrimary),
    },
});

selector('.alert', {
    border: css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColor)}`,
    '&.success': {
        borderColor: ref(borderColorSuccess),
        borderLeftWidth: ref(borderWidthMedium),
    },
    '&.warning': {
        borderColor: ref(borderColorWarning),
        borderLeftWidth: ref(borderWidthMedium),
    },
    '&.danger': {
        borderColor: ref(borderColorDanger),
        borderLeftWidth: ref(borderWidthMedium),
    },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-style--none: none;
    --border-style--solid: solid;
    --border-style--dashed: dashed;
    --border-style--dotted: dotted;
    --border-style--double: double;
    --border-style--groove: groove;
    --border-style--inset: inset;
    --border-style--outset: outset;
    --border-style: var(--border-style--solid);
    --border-width--none: 0;
    --border-width--thin: thin;
    --border-width--medium: medium;
    --border-width--thick: thick;
    --border-width: var(--border-width--thin);
    --color--gray: oklch(0.8485 0.0061 264.07 / 1);
    --color--primary: oklch(0.6109 0.1903 263.71 / 1);
    --color--success: oklch(0.7051 0.1654 165.47 / 1);
    --color--warning: oklch(0.7444 0.1609 60.67 / 1);
    --color--danger: oklch(0.6278 0.2158 27.33 / 1);
    --border-color: var(--color--gray);
    --border-color--primary: var(--color--primary);
    --border-color--success: var(--color--success);
    --border-color--warning: var(--color--warning);
    --border-color--danger: var(--color--danger);
}

.card {
    border: var(--border-width) var(--border-style) var(--border-color);
}

.input {
    border: var(--border-width) var(--border-style) var(--border-color);
}

.input:focus {
    border-color: var(--border-color--primary);
}

.alert {
    border: var(--border-width) var(--border-style) var(--border-color);
}

.alert.success {
    border-color: var(--border-color--success);
    border-left-width: var(--border-width--medium);
}

.alert.warning {
    border-color: var(--border-color--warning);
    border-left-width: var(--border-width--medium);
}

.alert.danger {
    border-color: var(--border-color--danger);
    border-left-width: var(--border-width--medium);
}
```

:::
::

## Examples

### Semantic Border Variables

Create semantic border variables that combine width, style, and color for easy reuse:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderStyle, useBorderWidth, useColor, useBorderColor } from 'styleframe/theme';

const s = styleframe();
const { ref, css } = s;

const { borderStyle } = useBorderStyle(s);
const { borderWidth } = useBorderWidth(s);
const { colorGray } = useColor(s, { gray: '#d1d5db' } as const);
const { borderColor } = useBorderColor(s, { default: ref(colorGray) } as const);

// Create complete semantic border variables
const border = s.variable(
    'border',
    css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColor)}`,
    { default: true }
);

const borderSubtle = s.variable(
    'border--subtle',
    css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColor, 0.5)}`,
    { default: true }
);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-style--none: none;
    --border-style--solid: solid;
    --border-style--dashed: dashed;
    --border-style--dotted: dotted;
    --border-style--double: double;
    --border-style--groove: groove;
    --border-style--inset: inset;
    --border-style--outset: outset;
    --border-style: var(--border-style--solid);
    --border-width--none: 0;
    --border-width--thin: thin;
    --border-width--medium: medium;
    --border-width--thick: thick;
    --border-width: var(--border-width--thin);
    --color--gray: oklch(0.8485 0.0061 264.07 / 1);
    --border-color: var(--color--gray);
    --border: var(--border-width) var(--border-style) var(--border-color);
    --border--subtle: var(--border-width) var(--border-style) oklch(from var(--border-color) l c h / 0.5);
}
```

:::
::

### Theme-Aware Borders

Create borders that automatically adapt to light and dark themes:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderStyle, useBorderWidth, useColor, useColorLightness, useBorderColor } from 'styleframe/theme';

const s = styleframe();
const { ref, selector, css } = s;

const { borderStyle } = useBorderStyle(s);
const { borderWidth } = useBorderWidth(s);

// Base color
const { colorGray } = useColor(s, { gray: '#6b7280' } as const);

// Create lightness variants
const { colorGray300, colorGray700 } = useColorLightness(s, colorGray, {
    300: 82,
    700: 35,
} as const);

// Light theme border colors
selector(':root', {
    '--border-color--theme': ref(colorGray300),
});

// Dark theme border colors
selector(':root[data-theme="dark"]', {
    '--border-color--theme': ref(colorGray700),
});

// Create border color variable that references the theme-aware color
const borderColorTheme = s.variable('border-color--theme');

// Use theme-aware border
selector('.card', {
    border: css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColorTheme)}`,
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --border-style--none: none;
    --border-style--solid: solid;
    --border-style--dashed: dashed;
    --border-style--dotted: dotted;
    --border-style--double: double;
    --border-style--groove: groove;
    --border-style--inset: inset;
    --border-style--outset: outset;
    --border-style: var(--border-style--solid);
    --border-width--none: 0;
    --border-width--thin: thin;
    --border-width--medium: medium;
    --border-width--thick: thick;
    --border-width: var(--border-width--thin);
    --color--gray: oklch(0.5575 0.0165 244.89 / 1);
    --color--gray-300: oklch(from var(--color--gray) 0.82 c h / a);
    --color--gray-700: oklch(from var(--color--gray) 0.35 c h / a);
    --border-color--theme: var(--color--gray-300);
}

:root[data-theme="dark"] {
    --border-color--theme: var(--color--gray-700);
}

.card {
    border: var(--border-width) var(--border-style) var(--border-color--theme);
}
```

:::
::

### State-Based Border Colors

Create border colors for different interactive states:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';
import { useBorderStyle, useBorderWidth, useColor, useBorderColor } from 'styleframe/theme';

const s = styleframe();
const { ref, selector, css } = s;

const { borderStyle } = useBorderStyle(s);
const { borderWidth } = useBorderWidth(s);

// Define base colors for different states
const { colorGray, colorBlue, colorRed, colorGreen } = useColor(s, {
    gray: '#d1d5db',
    blue: '#3b82f6',
    red: '#ef4444',
    green: '#10b981',
} as const);

// Create state-based border colors
const {
    borderColor,
    borderColorHover,
    borderColorFocus,
    borderColorError,
    borderColorSuccess,
} = useBorderColor(s, {
    default: ref(colorGray),
    hover: ref(colorBlue),
    focus: ref(colorBlue),
    error: ref(colorRed),
    success: ref(colorGreen),
} as const);

// Apply state-based borders
selector('.input', {
    border: css`${ref(borderWidth)} ${ref(borderStyle)} ${ref(borderColor)}`,
    transition: 'border-color 0.2s ease',
    '&:hover': {
        borderColor: ref(borderColorHover),
    },
    '&:focus': {
        borderColor: ref(borderColorFocus),
        outline: 'none',
    },
    '&.error': {
        borderColor: ref(borderColorError),
    },
    '&.success': {
        borderColor: ref(borderColorSuccess),
    },
});

export default s;
```

:::
::

## Best Practices

- **Use `useBorderColor()` for semantic separation**: Create border-specific color variables instead of directly referencing color variables. This gives you flexibility to adjust border colors independently.
- **Leverage default variables**: Use the `--border-style`, `--border-width`, and `--border-color` variables for consistency across your application.
- **Create complete border variables**: Combine width, style, and color into single variables (like `--border`) for frequently used border combinations.
- **Consider transparency**: Use alpha channel adjustments on border colors for subtle borders that work on any background.
- **Keep it simple**: Most applications only need 2-3 border widths and primarily use `solid` and `dashed` styles.
- **Test accessibility**: Ensure borders provide sufficient contrast and aren't the only indicator of interactive states.
- **Plan for themes**: Use `useBorderColor()` to create theme-aware border colors that automatically adapt to light/dark modes.

::note

**Good to know:** The `useBorderColor()` composable accepts any value, not just color references. You can pass direct color values, but using references from `useColor()` is recommended for consistency and maintainability.

::

## FAQ

::accordion

:::accordion-item{label="Why use useBorderColor instead of directly referencing colors?" icon="i-lucide-circle-help"}
`useBorderColor()` creates semantic separation between general colors and border colors. This allows you to adjust border colors independently (e.g., making them lighter, more desaturated, or transparent) without affecting your base color palette. It also makes your intent explicit when reading the code.
:::

:::accordion-item{label="When should I use border-style keywords vs custom values?" icon="i-lucide-circle-help"}
The composable provides all standard CSS border styles, which cover most use cases. Stick with these unless you have a specific design requirement. The most commonly used styles are `solid` (for most borders), `dashed` (for secondary or inactive states), and `none` (to remove borders).
:::

:::accordion-item{label="Should I use the CSS width keywords or pixel values?" icon="i-lucide-circle-help"}
CSS keywords (`thin`, `medium`, `thick`) are good defaults and are consistently rendered across browsers. Use pixel values when you need exact control, especially for hairline borders (`0.5px` or `1px`) or when your design system requires specific measurements.
:::

:::accordion-item{label="How do I create conditional borders?" icon="i-lucide-circle-help"}
You can create conditional borders by setting individual border properties. For example, use `borderTop` for top-only borders, or use `border: none` as a base and then override specific sides. You can also use the `--border-width--none` variable to effectively hide borders without changing the style or color.
:::

:::accordion-item{label="Can I animate border changes?" icon="i-lucide-circle-help"}
Yes! Border color and border width can be animated with CSS transitions. Border style changes are discrete and can't be smoothly animated. For smooth border animations, keep the style constant and animate the color or width properties.
:::

:::accordion-item{label="What's the best way to create focus indicators?" icon="i-lucide-circle-help"}
For accessibility, focus indicators should be clearly visible. Use a thicker border width (like `--border-width--medium`) combined with a high-contrast color. Consider using `outline` instead of `border` for focus states to avoid layout shifts, or ensure your components have space allocated for the border change.
:::

:::accordion-item{label="Can I use color manipulation with useBorderColor?" icon="i-lucide-circle-help"}
Yes! You can combine `useBorderColor()` with composables like `useColorLightness()`, `useColorShade()`, and `useColorTint()` to create sophisticated border color systems with automatic variants. Just pass the manipulated color references to `useBorderColor()`.
:::

::