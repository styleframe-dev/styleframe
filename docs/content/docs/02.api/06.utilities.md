---
title: Utilities
description: Styleframe utilities provide reusable, single-purpose CSS classes with full type safety and recipe support. Build consistent, maintainable styling systems with atomic design patterns.
navigation:
    icon: i-lucide-hammer
---

## Overview

Utilities in Styleframe are reusable, single-purpose CSS classes that provide a foundation for atomic design patterns. They offer full type safety, auto-complete, and seamless integration with recipes to create flexible, maintainable styling systems that scale with your project.

## Why use utilities?

Utilities help you:

- **Build atomic design patterns**: Create small, focused CSS classes that do one thing well and can be composed together.
- **Maintain consistency**: Ensure uniform spacing, colors, and typography across your entire application.
- **Enable rapid prototyping**: Quickly build interfaces by combining pre-defined utility classes.
- **Integrate with recipes**: Seamlessly work with responsive, state, and custom variants for maximum flexibility.

## Defining Utilities

You define utilities using the `utility()` function from your styleframe instance:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref, utility } = s;

const spacing = variable('spacing', '1rem');
const spacingSm = variable('spacing--sm', '0.75rem');
const spacingMd = variable('spacing--md', ref(spacing));
const spacingLg = variable('spacing--lg', '1.25rem');

const createMarginUtility = utility('margin', (value) => ({
    margin: value
}));

createMarginUtility({
    'default': ref(spacing),
    'sm': ref(spacingSm),
    'md': ref(spacingMd),
    'lg': ref(spacingLg),
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --spacing: 1rem;
    --spacing--sm: 0.75rem;
    --spacing--md: var(--spacing);
    --spacing--lg: 1.25rem;
}

._margin {
    margin: var(--spacing);
}

._margin\:sm {
    margin: var(--spacing--sm);
}

._margin\:md {
    margin: var(--spacing--md);
}

._margin\:lg {
    margin: var(--spacing--lg);
}
```

:::
::

The `utility()` function takes a **base name**, a **generator function**, and an optional **options object**. The base name is used to generate the utility class names, while the generator function defines how the utility should be applied.

The function returns a **utility creator** that you can call with an object containing value mappings. Each key in the object corresponds to a utility class, and the value is the CSS declaration to apply.

::note

**Good to know:** You can write utility names using `kebab-case`, `camelCase`, or `PascalCase`. When generating the utility classes, Styleframe will automatically convert them to `kebab-case` for consistency.

::

The default generated utility class format is `_property-name:value`, which is intuitive and CSS-like. You can customize this format in your styleframe configuration if needed.

::tip

**Pro tip:** Use descriptive utility names that clearly indicate their purpose. The CSS-like syntax makes utilities intuitive and easy to understand.

::
You're absolutely right! I should maintain consistency with the existing pattern. Here's the corrected version that adds `modifier` to the destructuring:

## Defining Utility Modifiers

Modifiers are functions that transform utility declarations to create variations based on conditions like hover states, media queries, or theme variations. 
They allow you to generate multiple related utility classes from a single base utility definition, extending your utilities with powerful conditional styling.

### Basic Modifier Usage

Let's start with a simple hover modifier to understand the concept:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { utility, variable, ref, modifier } = s;

const colorPrimary = variable('color-primary', '#007bff');

const hover = modifier('hover', (declarations) => ({
    [`&:hover`]: declarations
}));

const createBackgroundUtility = utility('background', (value) => ({
    background: value
}));

createBackgroundUtility({
    'primary': ref(colorPrimary),
}, {
    modifiers: [hover]
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --color-primary: #007bff;
}

._background\:primary {
    background: var(--color-primary);
}

._hover\:background\:primary {
    &:hover {
        background: var(--color-primary);
    }
}
```

:::
::

### Media Query Modifiers

You can create modifiers for responsive design using media queries:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { utility, variable, ref, modifier } = s;

const colorPrimary = variable('color-primary', '#007bff');
const colorSecondary = variable('color-secondary', '#6c757d');

// Media query modifier for dark mode
const dark = modifier('dark', (declarations) => ({
    ['@media (prefers-color-scheme: dark)']: declarations
}));

const createBackgroundUtility = utility('background', (value) => ({
    background: value
}));

createBackgroundUtility({
    'primary': ref(colorPrimary),
    'secondary': ref(colorSecondary),
}, {
    modifiers: [dark]
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --color-primary: #007bff;
    --color-secondary: #6c757d;
}

._background\:primary {
    background: var(--color-primary);
}

._background\:secondary {
    background: var(--color-secondary);
}

._dark\:background\:primary {
    @media (prefers-color-scheme: dark) {
        background: var(--color-primary);
    }
}

._dark\:background\:secondary {
    @media (prefers-color-scheme: dark) {
        background: var(--color-secondary);
    }
}
```

:::
::

### Multi-key Modifiers

You can create modifiers for responsive design using media queries:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe, valueOf } from 'styleframe';
import { useBreakpoints } from 'styleframe/theme';

const s = styleframe();
const {utility, variable, ref, modifier} = s;

const {
    breakpointSm,
    breakpointMd,
    breakpointLg,
} = useBreakpoints(s);

const breakpoints = {
    sm: valueOf(breakpointSm),
    md: valueOf(breakpointMd),
    lg: valueOf(breakpointLg),
}

const breakpointMax = modifier(['max-sm', 'max-md', 'max-lg'], (declarations, key) => ({
    [`@media screen and (max-width: ${
        breakpoints[key.replace('max-', '')]
    })`]: declarations
}));

const createHiddenUtility = utility('hidden', () => ({
    display: 'none'
}));

createHiddenUtility({ default: undefined }, {
    modifiers: [breakpointMax]
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --breakpoint-sm: 640px;
    --breakpoint-md: 768px;
    --breakpoint-lg: 1024px;
}

._hidden {
    display: none;
}

._max-sm\:hidden {
    @media screen and (max-width: 640px) {
        display: none;
    }
}

._max-md\:hidden {
    @media screen and (max-width: 768px) {
        display: none;
    }
}

._max-lg\:hidden {
    @media screen and (max-width: 1024px) {
        display: none;
    }
}
```

:::
::

### Combining Multiple Modifiers

Modifiers can be combined to create complex utility variations that handle multiple conditions:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { utility, variable, ref, modifier } = s;

const colorPrimary = variable('color-primary', '#007bff');
const colorSecondary = variable('color-secondary', '#6c757d');

// Define multiple modifiers
const hover = modifier('hover', (declarations) => ({
    [`&:hover`]: declarations
}));

const dark = modifier('dark', (declarations) => ({
    ['@media (prefers-color-scheme: dark)']: declarations
}));

const focus = modifier('focus', (declarations) => ({
    [`&:focus`]: declarations
}));

const createBackgroundUtility = utility('background', (value) => ({
    background: value
}));

// Apply multiple modifiers to the same utility
createBackgroundUtility({
    'primary': ref(colorPrimary),
    'secondary': ref(colorSecondary),
}, {
    modifiers: [hover, dark, focus]
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --color-primary: #007bff;
    --color-secondary: #6c757d;
}

/* Base utilities */
._background\:primary {
    background: var(--color-primary);
}

._background\:secondary {
    background: var(--color-secondary);
}

/* Hover variations */
._hover\:background\:primary {
    &:hover {
        background: var(--color-primary);
    }
}

._hover\:background\:secondary {
    &:hover {
        background: var(--color-secondary);
    }
}

/* Dark mode variations */
._dark\:background\:primary {
    @media (prefers-color-scheme: dark) {
        background: var(--color-primary);
    }
}

._dark\:background\:secondary {
    @media (prefers-color-scheme: dark) {
        background: var(--color-secondary);
    }
}

/* Focus variations */
._focus\:background\:primary {
    &:focus {
        background: var(--color-primary);
    }
}

._focus\:background\:secondary {
    &:focus {
        background: var(--color-secondary);
    }
}

/* Combined modifier variations (dark + hover, dark + focus, etc.) */
._dark\:hover\:background\:primary {
    @media (prefers-color-scheme: dark) {
        &:hover {
            background: var(--color-primary);
        }
    }
}

/* ... and more combinations */
```

:::
::

::note

**Good to know:** When multiple modifiers are combined, Styleframe automatically generates all possible combinations in alphabetical order, giving you fine-grained control over when styles are applied.

::

### Reusable Modifier Patterns

Create reusable modifier patterns for consistent styling across your utilities:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}
```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { utility, variable, ref, modifier } = s;

// Create reusable modifier patterns
const hover = modifier('hover', (declarations) => ({
[`&:hover`]: declarations
}));

const mobile = modifier('mobile', (declarations) => ({
[`@media screen and (max-width: 768px)`]: declarations
}));

const focus = modifier('focus', (declarations) => ({
[`&:focus`]: declarations
}));

// Use them with multiple utilities
const colorDanger = variable('color-danger', '#dc3545');

const createTextUtility = utility('text', (value) => ({
color: value
}));

createTextUtility({
'danger': ref(colorDanger),
}, {
modifiers: [hover, mobile, focus]
});

export default s;
```
:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --color-danger: #dc3545;
}

._text\:danger {
    color: var(--color-danger);
}

._hover\:text\:danger:hover {
    color: var(--color-danger);
}

._mobile\:text\:danger {
    @media screen and (max-width: 768px) {
        color: var(--color-danger);
    }
}

._focus\:text\:danger:focus {
    color: var(--color-danger);
}
```
```


:::
::

::tip

**Pro tip:** The `modifier()` function creates reusable transformation patterns that can be applied to any utility, promoting consistency across your design system.

::

### Usage in Components

Here's how you would use modifier-generated utilities in your components:

```html
<!-- Base utility -->
<button class="_background:primary">
  Primary Button
</button>

<!-- With hover modifier -->
<button class="_hover:background:primary">
  Hover Button
</button>

<!-- With multiple modifiers -->
<button class="_dark:hover:background:primary _focus:background:primary">
  Interactive Button
</button>
```





## Responsive Utilities

Behind the scenes, the `utility()` function creates a selector.
Styleframe utilities can be easily adapted for responsive design by using media queries.  You can define responsive utilities that apply different styles based on screen size breakpoints the same way you do for selectors.


::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe, valueOf } from 'styleframe';
import { useBreakpoints } from 'styleframe/theme';

const s = styleframe();
const { utility } = s;

const {
    breakpointSm,
    breakpointMd,
    breakpointLg,
    breakpointXl
} = useBreakpoints();

const hover = modifier('hover', (name, declarations) => ({
    [`&:hover`]: declarations
}), { prefix: true });

const breakpoint = modifier('breakpoint', (name, declarations) => ({
    [`@media screen and (max-width: ${value})`]: declarations
}), { prefix: true });

utility('hidden', (value) => ({
    display: 'none'
}), {
    modifiers: [breakpoint]
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
.hidden\:sm {
    @media screen and (max-width: 640px) {
        display: none;
    }
}

.hidden\:md {
    @media screen and (max-width: 768px) {
        display: none;
    }
}

.hidden\:lg {
    @media screen and (max-width: 1024px) {
        display: none;
    }
}

.hidden\:xl {
    @media screen and (max-width: 1280px) {
        display: none;
    }
}
```

:::
::


## Examples

### Layout Utilities

Build flexible layout systems with display and positioning utilities:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { utility } = s;

const createDisplayUtility = utility('display', (value) => ({
    display: value,
}));

createDisplayUtility({
    'block': 'block',
    'inline-block': 'inline-block',
    'inline': 'inline',
    'flex': 'flex',
    'inline-flex': 'inline-flex',
    'grid': 'grid',
    'none': 'none',
});

const createFlexDirectionUtility = utility('flex-direction', (value) => ({
    flexDirection: value,
}));

createFlexDirectionUtility({
    'row': 'row',
    'column': 'column',
});

const createJustifyContentUtility = utility('justify-content', (value) => ({
    justifyContent: value,
}));

createJustifyContentUtility({
    'start': 'flex-start',
    'center': 'center',
    'end': 'flex-end',
    'between': 'space-between',
});

const createAlignItemsUtility = utility('align-items', (value) => ({
    alignItems: value,
}));

createAlignItemsUtility({
    'start': 'flex-start',
    'center': 'center',
    'end': 'flex-end',
    'stretch': 'stretch',
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
._display\:block { display: block; }
._display\:inline-block { display: inline-block; }
._display\:inline { display: inline; }
._display\:flex { display: flex; }
._display\:inline-flex { display: inline-flex; }
._display\:grid { display: grid; }
._display\:none { display: none; }

._flex-direction\:row { flex-direction: row; }
._flex-direction\:column { flex-direction: column; }

._justify-content\:start { justify-content: flex-start; }
._justify-content\:center { justify-content: center; }
._justify-content\:end { justify-content: flex-end; }
._justify-content\:between { justify-content: space-between; }

._align-items\:start { align-items: flex-start; }
._align-items\:center { align-items: center; }
._align-items\:end { align-items: flex-end; }
._align-items\:stretch { align-items: stretch; }
```

:::
::


### Complex Utilities

Create sophisticated utility systems that handle complex CSS properties and calculations:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe, css } from 'styleframe';

const s = styleframe();
const { variable, ref, utility } = s;

const createGridColumnUtility = utility('grid-column', (value) => ({
    gridColumn: css`span ${value} / span ${value}`,
}));

const gridSpanMap = {};
for (let i = 1; i <= 12; i++) {
    gridSpanMap[i] = i;
}

createGridColumnUtility(gridSpanMap);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
._grid-column\:1 { grid-column: span 1 / span 1; }
._grid-column\:2 { grid-column: span 2 / span 2; }
._grid-column\:3 { grid-column: span 3 / span 3; }
/* ... */
._grid-column\:12 { grid-column: span 12 / span 12; }
```

:::
::

## Best Practices

- **Keep utilities focused**: Each utility should have a single, clear responsibility and do one thing well.
- **Use descriptive naming**: The `_property:value` format makes utilities intuitive and CSS-like to use.
- **Leverage variables**: Build utilities on top of your design system variables for consistency and maintainability.
- **Create composables**: Group related utilities into composable functions for better organization and reusability.
- **Integrate with variants**: Design utilities to work seamlessly with responsive, state, and custom variants.
- **Batch utility creation**: Use object mapping to create multiple related utilities efficiently.

## FAQ

::accordion

:::accordion-item{label="How do utilities differ from components?" icon="i-lucide-circle-help"}
Utilities are single-purpose classes focused on individual CSS properties, while components are collections of styles that define entire UI elements.
:::

:::accordion-item{label="Why use this utility class format?" icon="i-lucide-circle-help"}
The `_property:value` format is more natural and CSS-like, making it intuitive for developers familiar with CSS. It clearly separates the property from the value while maintaining readability.
:::

:::accordion-item{label="Can I create conditional utilities?" icon="i-lucide-circle-help"}
Yes, you can use JavaScript logic when building the value mappings to create conditional utilities based on configuration or runtime values.
:::

:::accordion-item{label="How do I handle utility naming conflicts?" icon="i-lucide-circle-help"}
The `_property:value` format naturally prevents most conflicts by being explicit about the CSS property being targeted.
:::

:::accordion-item{label="Can utilities work with CSS-in-JS patterns?" icon="i-lucide-circle-help"}
Absolutely! Utilities generate standard CSS classes that work with any styling approach, including CSS-in-JS libraries.
:::

:::accordion-item{label="How do I optimize utility bundle size?" icon="i-lucide-circle-help"}
Generate only the utilities you need by conditionally building value mappings based on your design system requirements.
:::

::
