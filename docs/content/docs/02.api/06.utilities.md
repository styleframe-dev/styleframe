---
title: Utilities
description: Styleframe utilities provide reusable, single-purpose CSS classes with full type safety and recipe support. Build consistent, maintainable styling systems with atomic design patterns.
navigation:
    icon: i-lucide-hammer
---

## Overview

Utilities in Styleframe are reusable, single-purpose CSS classes that provide a foundation for atomic design patterns. They offer full type safety, auto-complete, and seamless integration with recipes to create flexible, maintainable styling systems that scale with your project.

## Why use utilities?

Utilities help you:

- **Build atomic design patterns**: Create small, focused CSS classes that do one thing well and can be composed together.
- **Maintain consistency**: Ensure uniform spacing, colors, and typography across your entire application.
- **Enable rapid prototyping**: Quickly build interfaces by combining pre-defined utility classes.
- **Integrate with recipes**: Seamlessly work with responsive, state, and custom variants for maximum flexibility.

## Defining Utilities

You define utilities using the `utility()` function from your styleframe instance:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref, utility } = s;

const spacing = variable('spacing', '1rem');
const spacingSm = variable('spacing--sm', '0.75rem');
const spacingMd = variable('spacing--md', ref(spacing));
const spacingLg = variable('spacing--lg', '1.25rem');

const createMarginUtility = utility('margin', (value) => ({
    margin: value
}), {
    default: ref(spacing),
    sm: ref(spacingSm),
    md: ref(spacingMd),
    lg: ref(spacingLg)
});
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --spacing: 1rem;
    --spacing--sm: 0.75rem;
    --spacing--md: var(--spacing);
    --spacing--lg: 1.25rem;
}

._margin {
    margin: var(--spacing);
}

._margin\:sm {
    margin: var(--spacing--sm);
}

._margin\:md {
    margin: var(--spacing--md);
}

._margin\:lg {
    margin: var(--spacing--lg);
}
```

:::
::

The `utility()` function takes a **base name**, a **generator function**, and the **values** to create utility classes from.

::note

**Good to know:** You can write utility names using `kebab-case`, `camelCase`, or `PascalCase`. When generating the utility classes, Styleframe will automatically convert them to `kebab-case` for consistency.

::

The default generated utility class format is `_property-name:value`, which is intuitive and CSS-like. You can customize this format in your styleframe configuration if needed.

::tip

**Pro tip:** Use descriptive utility names that clearly indicate their purpose. The CSS-like syntax makes utilities intuitive and easy to understand.

::


## Utility Generators

The `utility()` function returns a **utility creator**. You can call this creator with an object containing the value mappings to generate utility classes with the format you choose.

Create flexible utility systems by defining generator functions that can produce multiple related classes:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref, utility } = s;

const spacing0 = variable('spacing--0', '0');
const spacing1 = variable('spacing--1', '0.25rem');
const spacing2 = variable('spacing--2', '0.5rem');
const spacing3 = variable('spacing--3', '0.75rem');
const spacing4 = variable('spacing--4', '1rem');

const spacingMap = {
    '0': ref(spacing0),
    '1': ref(spacing1),
    '2': ref(spacing2),
    '3': ref(spacing3),
    '4': ref(spacing4),
};

const createPaddingUtility = utility('padding', (value) => ({
    padding: value,
}));

const createPaddingTopUtility = utility('padding-top', (value) => ({
    paddingTop: value,
}));

const createPaddingRightUtility = utility('padding-right', (value) => ({
    paddingRight: value,
}));

const createPaddingBottomUtility = utility('padding-bottom', (value) => ({
    paddingBottom: value,
}));

const createPaddingLeftUtility = utility('padding-left', (value) => ({
    paddingLeft: value,
}));

createPaddingUtility(spacingMap);
createPaddingTopUtility(spacingMap);
createPaddingRightUtility(spacingMap);
createPaddingBottomUtility(spacingMap);
createPaddingLeftUtility(spacingMap);
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
:root {
    --spacing--0: 0;
    --spacing--1: 0.25rem;
    --spacing--2: 0.5rem;
    --spacing--3: 0.75rem;
    --spacing--4: 1rem;
}

._padding\:0 { padding: var(--spacing--0); }
._padding\:1 { padding: var(--spacing--1); }
._padding\:2 { padding: var(--spacing--2); }
._padding\:3 { padding: var(--spacing--3); }
._padding\:4 { padding: var(--spacing--4); }

._padding-top\:0 { padding-top: var(--spacing--0); }
._padding-top\:1 { padding-top: var(--spacing--1); }
._padding-top\:2 { padding-top: var(--spacing--2); }
._padding-top\:3 { padding-top: var(--spacing--3); }
._padding-top\:4 { padding-top: var(--spacing--4); }

._padding-right\:0 { padding-right: var(--spacing--0); }
._padding-right\:1 { padding-right: var(--spacing--1); }
._padding-right\:2 { padding-right: var(--spacing--2); }
._padding-right\:3 { padding-right: var(--spacing--3); }
._padding-right\:4 { padding-right: var(--spacing--4); }

._padding-bottom\:0 { padding-bottom: var(--spacing--0); }
._padding-bottom\:1 { padding-bottom: var(--spacing--1); }
._padding-bottom\:2 { padding-bottom: var(--spacing--2); }
._padding-bottom\:3 { padding-bottom: var(--spacing--3); }
._padding-bottom\:4 { padding-bottom: var(--spacing--4); }

._padding-left\:0 { padding-left: var(--spacing--0); }
._padding-left\:1 { padding-left: var(--spacing--1); }
._padding-left\:2 { padding-left: var(--spacing--2); }
._padding-left\:3 { padding-left: var(--spacing--3); }
._padding-left\:4 { padding-left: var(--spacing--4); }
```

:::
::

## Responsive Utilities

Behind the scenes, the `utility()` function creates a selector.
Styleframe utilities can be easily adapted for responsive design by using media queries.  You can define responsive utilities that apply different styles based on screen size breakpoints the same way you do for selectors.


::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe, valueOf } from 'styleframe';
import { useBreakpoints } from 'styleframe/theme';

const s = styleframe();
const { utility } = s;

const {
    breakpointSm,
    breakpointMd,
    breakpointLg,
    breakpointXl
} = useBreakpoints();

utility('hidden', (value) => ({
    [`@media screen and (max-width: ${value})`]: {
        display: 'none'
    }
}), {
    'sm': valueOf(breaktpointSm),
    'md': valueOf(breakpointMd),
    'lg': valueOf(breakpointLg),
    'xl': valueOf(breakpointXl)
});
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
.hidden\:sm {
    @media screen and (max-width: 640px) {
        display: none;
    }
}

.hidden\:md {
    @media screen and (max-width: 768px) {
        display: none;
    }
}

.hidden\:lg {
    @media screen and (max-width: 1024px) {
        display: none;
    }
}

.hidden\:xl {
    @media screen and (max-width: 1280px) {
        display: none;
    }
}
```

:::
::


## Examples

### Layout Utilities

Build flexible layout systems with display and positioning utilities:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { utility } = s;

utility('display', (value) => ({
    display: value,
}), {
    'block': 'block',
    'inline-block': 'inline-block',
    'inline': 'inline',
    'flex': 'flex',
    'inline-flex': 'inline-flex',
    'grid': 'grid',
    'none': 'none',
});

utility('flex-direction', (value) => ({
    flexDirection: value,
}), {
    'row': 'row',
    'column': 'column',
});

utility('justify-content', (value) => ({
    justifyContent: value,
}), {
    'start': 'flex-start',
    'center': 'center',
    'end': 'flex-end',
    'between': 'space-between',
});

utility('align-items', (value) => ({
    alignItems: value,
}), {
    'start': 'flex-start',
    'center': 'center',
    'end': 'flex-end',
    'stretch': 'stretch',
});
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
._display\:block { display: block; }
._display\:inline-block { display: inline-block; }
._display\:inline { display: inline; }
._display\:flex { display: flex; }
._display\:inline-flex { display: inline-flex; }
._display\:grid { display: grid; }
._display\:none { display: none; }

._flex-direction\:row { flex-direction: row; }
._flex-direction\:column { flex-direction: column; }

._justify-content\:start { justify-content: flex-start; }
._justify-content\:center { justify-content: center; }
._justify-content\:end { justify-content: flex-end; }
._justify-content\:between { justify-content: space-between; }

._align-items\:start { align-items: flex-start; }
._align-items\:center { align-items: center; }
._align-items\:end { align-items: flex-end; }
._align-items\:stretch { align-items: stretch; }
```

:::
::


### Complex Utilities

Create sophisticated utility systems that handle complex CSS properties and calculations:

::tabs
:::tabs-item{.my-5 icon="i-lucide-code" label="Code"}

```ts
import { styleframe, css } from 'styleframe';

const s = styleframe();
const { variable, ref, utility } = s;

const createGridColumnUtility = utility('grid-column', (value) => ({
    gridColumn: css`span ${value} / span ${value}`,
}));

const gridSpanMap = {};
for (let i = 1; i <= 12; i++) {
    gridSpanMap[i] = i;
}

createGridColumnUtility(gridSpanMap);
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css
._grid-column\:1 { grid-column: span 1 / span 1; }
._grid-column\:2 { grid-column: span 2 / span 2; }
._grid-column\:3 { grid-column: span 3 / span 3; }
/* ... */
._grid-column\:12 { grid-column: span 12 / span 12; }
```

:::
::

## Best Practices

- **Keep utilities focused**: Each utility should have a single, clear responsibility and do one thing well.
- **Use descriptive naming**: The `_property:value` format makes utilities intuitive and CSS-like to use.
- **Leverage variables**: Build utilities on top of your design system variables for consistency and maintainability.
- **Create composables**: Group related utilities into composable functions for better organization and reusability.
- **Integrate with variants**: Design utilities to work seamlessly with responsive, state, and custom variants.
- **Batch utility creation**: Use object mapping to create multiple related utilities efficiently.

## FAQ

- **How do utilities differ from components?**  
  Utilities are single-purpose classes focused on individual CSS properties, while components are collections of styles that define entire UI elements.

- **Why use the `_property:value` format?**  
  This format is more natural and CSS-like, making it intuitive for developers familiar with CSS. It clearly separates the property from the value while maintaining readability.

- **Can I create conditional utilities?**  
  Yes, you can use JavaScript logic when building the value mappings to create conditional utilities based on configuration or runtime values.

- **How do I handle utility naming conflicts?**  
  The `_property:value` format naturally prevents most conflicts by being explicit about the CSS property being targeted.

- **Can utilities work with CSS-in-JS patterns?**  
  Absolutely! Utilities generate standard CSS classes that work with any styling approach, including CSS-in-JS libraries.

- **How do I optimize utility bundle size?**  
  Generate only the utilities you need by conditionally building value mappings based on your design system requirements.
