---
title: API Overview
description: Explore Styleframe's comprehensive API for building type-safe, maintainable design systems. From variables and selectors to themes and composables, discover how to create scalable styling architectures.
navigation:
    title: Overview
    icon: i-lucide-book-text
---

Styleframe provides a powerful, type-safe API for building modern CSS design systems. The API is designed around **composability**, **type safety**, and **maintainability**, enabling you to create scalable styling architectures that grow with your application.

Every Styleframe feature works together seamlessly, allowing you to build sophisticated design systems while maintaining clean, organized code.

## Getting Started

All Styleframe features are accessed through a styleframe instance:

```ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, selector, ref } = s;

// Start building your design system
const colorPrimary = variable('color--primary', '#006cff');

selector('.button', {
    backgroundColor: ref(colorPrimary),
    padding: '0.5rem 1rem',
});

export default s;
```

## Core Building Blocks

These fundamental features form the foundation of every Styleframe design system.

### Variables

Variables are the foundation of your design system. They let you define design tokens such as colors, spacing, typography, and more, with full type safety and auto-complete.

**Key capabilities:**
- Define reusable design tokens
- Reference variables in other styles
- Enable easy theming and customization
- Become CSS custom properties

```ts
const colorPrimary = variable('color--primary', '#006cff');
const spacingMd = variable('spacing--md', '1rem');
```

[Learn more about Variables â†’](/docs/api/variables)

### Selectors

Selectors allow you to create CSS rules with type-safe property definitions. They provide a powerful way to style your components with full TypeScript support.

**Key capabilities:**
- Write type-safe CSS with auto-complete
- Nest selectors for better organization
- Support all CSS selectors and pseudo-classes
- Compose with variables and other features

```ts
selector('.button', {
    padding: ref(spacingMd),
    backgroundColor: ref(colorPrimary),
    
    '&:hover': {
        opacity: 0.9,
    },
});
```

[Learn more about Selectors â†’](/docs/api/selectors)

### At-Rules

At-rules enable you to use modern CSS features like container queries, feature detection, font loading, and CSS layers with full type safety.

**Key capabilities:**
- Support all CSS at-rules (`@supports`, `@font-face`, `@layer`, `@container`, etc.)
- Progressive enhancement with feature detection
- Custom font loading with optimal characteristics
- CSS cascade organization with layers

```ts
atRule('supports', '(display: grid)', ({ selector }) => {
    selector('.layout', {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
    });
});
```

[Learn more about At-Rules â†’](/docs/api/at-rules)

### Media Queries

Media queries enable responsive design with type-safe breakpoint definitions. Create adaptive layouts that work seamlessly across all device sizes.

**Key capabilities:**
- Define responsive breakpoints
- Support all media query features
- Nest media queries within selectors
- Use inline or callback-based syntax

```ts
media('(min-width: 768px)', ({ selector }) => {
    selector('.container', {
        width: '750px',
        margin: '0 auto',
    });
});
```

[Learn more about Media Queries â†’](/docs/api/media-queries)

### Keyframes

Keyframes enable you to create smooth CSS animations with type-safe property definitions. Build engaging motion effects that enhance user experience.

**Key capabilities:**
- Define animation sequences
- Reference in any selector
- Combine with variables for consistency
- Support all animatable CSS properties

```ts
const fadeIn = keyframes('fade-in', {
    '0%': { opacity: 0, transform: 'translateY(20px)' },
    '100%': { opacity: 1, transform: 'translateY(0)' },
});

selector('.animated', {
    animation: `${fadeIn.name} 0.3s ease-out`,
});
```

[Learn more about Keyframes â†’](/docs/api/keyframes)

### Interpolation

The `css` template literal utility enables dynamic value insertion with full type safety. Create flexible, maintainable CSS values that adapt to your design system.

**Key capabilities:**
- Combine variables with static values
- Create complex CSS calculations
- Build dynamic gradients and transforms
- Maintain type safety in template literals

```ts
selector('.gradient', {
    background: css`linear-gradient(135deg, ${ref(colorPrimary)} 0%, ${ref(colorSecondary)} 100%)`,
    padding: css`clamp(${ref(spacingSm)}, 5vw, ${ref(spacingLg)})`,
});
```

[Learn more about Interpolation â†’](/docs/api/interpolation)

### Utilities

Utilities provide reusable, single-purpose CSS classes with full type safety and modifier support. Build consistent, maintainable styling systems with atomic design patterns.

**Key capabilities:**
- Create atomic CSS classes
- Define reusable modifiers (hover, focus, responsive)
- Generate variants automatically
- Support compound modifier combinations

```ts
const createMarginUtility = utility('margin', ({ value }) => ({
    margin: value,
}));

const hover = modifier('hover', ({ declarations }) => ({
    '&:hover': declarations,
}));

createMarginUtility(
    { sm: '0.5rem', md: '1rem', lg: '1.5rem' },
    [hover]
);
```

[Learn more about Utilities â†’](/docs/api/utilities)

### Themes

Themes provide powerful design system theming capabilities with type-safe variable overrides. Create consistent variations like dark mode, brand themes, or user personalization.

**Key capabilities:**
- Override variables in specific contexts
- Create multiple theme variations
- Apply themes with data attributes
- Maintain consistency across variations

```ts
theme('dark', (ctx) => {
    ctx.variable(colorBackground, '#18181b');
    ctx.variable(colorText, '#ffffff');
});
```

[Learn more about Themes â†’](/docs/api/themes)

### Recipes ðŸš§

Recipes provide component variants with type-safe configuration options. Create flexible, reusable UI components with runtime variant selection.

**Key capabilities:**
- Generate runtime variant functions
- Leverage existing utility classes
- Support compound variants
- Define default configurations

::warning
**Note**: Recipes are under active development and not yet available.
::

[Learn more about Recipes â†’](/docs/api/recipes)

## Organization & Composition

Structure and scale your design system with these organizational features.

### Composables

Composables are reusable functions that provide design system components. They enable modular, consistent styling patterns across your application.

**Key capabilities:**
- Create reusable design system modules
- Group related variables and styles
- Build configurable styling functions
- Compose design systems from building blocks

```ts
export function useColorVariables(s: Styleframe) {
    const { variable } = s;
    
    const colorPrimary = variable('color--primary', '#006cff', { default: true });
    const colorSecondary = variable('color--secondary', '#64748b', { default: true });
    
    return { colorPrimary, colorSecondary };
}
```

[Learn more about Composables â†’](/docs/api/composables)

### Merging

The `merge()` function combines multiple Styleframe instances into a single unified configuration. Perfect for composing design systems and building modular architectures.

**Key capabilities:**
- Combine multiple styleframe instances
- Share configurations across projects
- Override and extend base configurations
- Organize large codebases into modules

```ts
import { merge } from 'styleframe';
import base from './base';
import theme from './theme';
import components from './components';

const s = merge(base, theme, components);
```

[Learn more about Merging â†’](/docs/api/merging)


## API Reference Summary

| Feature | Purpose | Key Use Cases |
|---------|---------|---------------|
| [Variables](/docs/api/variables) | Design tokens with type safety | Colors, spacing, typography |
| [Selectors](/docs/api/selectors) | Type-safe CSS rules | Component styles, layouts |
| [At-Rules](/docs/api/at-rules) | Modern CSS features | Feature detection, fonts, layers |
| [Media Queries](/docs/api/media-queries) | Responsive design | Breakpoints, adaptive layouts |
| [Keyframes](/docs/api/keyframes) | CSS animations | Motion effects, transitions |
| [Interpolation](/docs/api/interpolation) | Dynamic CSS values | Complex calculations, gradients |
| [Utilities](/docs/api/utilities) | Atomic CSS classes | Utility-first styling |
| [Themes](/docs/api/themes) | Design variations | Dark mode, brand themes |
| [Recipes](/docs/api/recipes) | Component variants | Button variants, card styles |
| [Composables](/docs/api/composables) | Reusable modules | Design system organization |
| [Merging](/docs/api/merging) | Instance composition | Shared configurations |

## Next Steps

Ready to dive deeper? Explore specific API features:

- **New to Styleframe?** Start with [Variables](/docs/api/variables) and [Selectors](/docs/api/selectors)
- **Building a design system?** Check out [Composables](/docs/api/composables) and [Themes](/docs/api/themes)
- **Need utilities?** Learn about [Utilities](/docs/api/utilities) and modifiers
- **Working on responsive design?** Explore [Media Queries](/docs/api/media-queries) and [At-Rules](/docs/api/at-rules)
- **Want to share code?** Discover [Merging](/docs/api/merging) patterns

Each API feature is designed to work seamlessly with the others, giving you the flexibility to build exactly the design system your project needs.
