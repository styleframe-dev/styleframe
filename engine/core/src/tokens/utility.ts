import { transformUtilityKey } from "../defaults";
import { isRef } from "../typeGuards";
import type {
	Container,
	ModifierFactory,
	Root,
	TokenValue,
	Utility,
	UtilityAutogenerateFn,
	UtilityCallbackFn,
	UtilityCreatorFn,
	UtilityFactory,
} from "../types";
import {
	createDeclarationsCallbackContext,
	parseDeclarationsBlock,
} from "./declarations";
import { applyModifiers, combineKeys } from "./modifier";

export function createModifiedUtilityInstances(
	baseInstance: Utility,
	availableModifiers: ModifierFactory[],
	root: Root,
): Utility[] {
	const modifierKeys = availableModifiers.map((modifier) => modifier.key);
	const modifierKeyCombinations = combineKeys(modifierKeys);

	return modifierKeyCombinations.map((combination) => {
		const modifiers = new Map<string, ModifierFactory>();

		for (const modifierKey of combination) {
			const modifier = availableModifiers.find((modifier) =>
				modifier.key.includes(modifierKey),
			);
			if (modifier) modifiers.set(modifierKey, modifier);
		}

		return applyModifiers(baseInstance, root, modifiers);
	});
}

export function createUtilityFunction(parent: Container, root: Root) {
	return function utility<Name extends string>(
		name: Name,
		factory: UtilityCallbackFn,
		options: { autogenerate?: UtilityAutogenerateFn } = {},
	): UtilityCreatorFn {
		const factoryInstance: UtilityFactory<Name> = {
			type: "utility",
			name,
			factory,
			values: {},
			autogenerate: options.autogenerate,
		};

		root.utilities.push(factoryInstance);

		const autogenerate = factoryInstance.autogenerate ?? transformUtilityKey();

		const utilityCreatorFn: UtilityCreatorFn = (entries, modifiers) => {
			let resolvedEntries = entries;

			if (Array.isArray(entries)) {
				/**
				 * If entries is an array, convert it to an object with relevant keys and values
				 *
				 * @example Arbitrary value: ['red'] => { '[red]': 'red' }
				 * @example Token reference: ['@color.primary'] => { 'color.primary': ref('color.primary') }
				 * @example Token reference with replacement: ['@color.primary'] => { 'primary': ref('color.primary') }
				 */
				resolvedEntries = {};

				for (const value of entries) {
					const autogeneratedEntries = autogenerate(value);

					resolvedEntries = {
						...resolvedEntries,
						...autogeneratedEntries,
					};
				}
			}

			for (const [key, value] of Object.entries(resolvedEntries)) {
				factoryInstance.values[key] = value;

				const instance: Utility<Name> = {
					type: "utility",
					name,
					value: key,
					declarations: {},
					variables: [],
					children: [],
					modifiers: [],
				};

				const callbackContext = createDeclarationsCallbackContext(
					instance,
					root,
				);

				instance.declarations =
					factory({
						...callbackContext,
						value,
					}) ?? {};

				parseDeclarationsBlock(instance.declarations, callbackContext);

				// Store the utility value on the instance
				parent.children.push(instance);

				// Create modified variants for this specific value
				if (modifiers && modifiers.length > 0) {
					parent.children.push(
						...createModifiedUtilityInstances(instance, modifiers, root),
					);
				}
			}
		};

		return utilityCreatorFn;
	};
}
