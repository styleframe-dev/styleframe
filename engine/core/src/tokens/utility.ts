import { transformUtilityKey } from "../defaults";
import { isModifier, isRef } from "../typeGuards";
import type {
	Container,
	ModifierFactory,
	Reference,
	Root,
	TokenValue,
	Utility,
	UtilityAutogenerateFn,
	UtilityCallbackFn,
	UtilityCreatorFn,
	UtilityFactory,
} from "../types";
import {
	createDeclarationsCallbackContext,
	parseDeclarationsBlock,
} from "./declarations";
import { applyModifiers, combineKeys } from "./modifier";

/**
 * Create an autogenerate function for namespace arrays that resolves
 * against root.variables to pick the first namespace with a defined variable.
 */
function createNamespaceAutogenerate(
	namespaces: string[],
	root: Root,
): UtilityAutogenerateFn {
	const baseTransform = transformUtilityKey({ namespace: namespaces });

	return (value: TokenValue): Record<string, TokenValue> => {
		if (typeof value === "string" && value[0] === "@") {
			const variableName = value.slice(1);

			// Try each namespace and pick the first with a defined variable
			for (const ns of namespaces) {
				const candidateName = `${ns}.${variableName}`;
				if (root.variables.some((v) => v.name === candidateName)) {
					return {
						[variableName]: {
							type: "reference",
							name: candidateName,
						} satisfies Reference<string>,
					};
				}
			}

			// No variable found â€” fall back to first namespace as default
			return baseTransform(value);
		}

		// For non-@ values (refs, arbitrary), delegate to base transform
		return baseTransform(value);
	};
}

export function createUtilityFunction(parent: Container, root: Root) {
	return function utility<Name extends string>(
		name: Name,
		factory: UtilityCallbackFn,
		options: {
			autogenerate?: UtilityAutogenerateFn;
			namespace?: string | string[];
		} = {},
	): UtilityCreatorFn {
		const factoryInstance: UtilityFactory<Name> = {
			type: "utility",
			name,
			factory,
			values: [],
			autogenerate:
				options.autogenerate ??
				(Array.isArray(options.namespace)
					? createNamespaceAutogenerate(options.namespace, root)
					: transformUtilityKey(
							options.namespace ? { namespace: options.namespace } : undefined,
						)),
			namespace: options.namespace,
			create: (entries, modifiers = []) => {
				let resolvedEntries = entries;

				if (Array.isArray(entries)) {
					/**
					 * If entries is an array, convert it to an object with relevant keys and values
					 *
					 * @example Arbitrary value: ['red'] => { '[red]': 'red' }
					 * @example Token reference: ['@color.primary'] => { 'color.primary': ref('color.primary') }
					 * @example Token reference with replacement: ['@color.primary'] => { 'primary': ref('color.primary') }
					 */
					resolvedEntries = {};

					for (const value of entries) {
						const autogeneratedEntries = factoryInstance.autogenerate(value);

						resolvedEntries = {
							...resolvedEntries,
							...autogeneratedEntries,
						};
					}
				}

				for (const [key, entryValue] of Object.entries(resolvedEntries)) {
					let value = entryValue;

					if (factoryInstance.namespace && isRef(entryValue)) {
						if (root.variables.some((v) => v.name === entryValue.name)) {
							value = entryValue;
						} else {
							const namespaces = Array.isArray(factoryInstance.namespace)
								? factoryInstance.namespace
								: [factoryInstance.namespace];

							let found = false;
							for (const ns of namespaces) {
								const candidateName = `${ns}.${key}`;
								if (
									candidateName !== entryValue.name &&
									root.variables.some((v) => v.name === candidateName)
								) {
									value = {
										type: "reference",
										name: candidateName,
									} satisfies Reference<string>;
									found = true;
									break;
								}
							}

							if (!found) {
								value = key;
							}
						}
					}

					const existingEntry = factoryInstance.values.find(
						(entry) => entry.key === key && entry.modifiers.length === 0,
					);

					const instance: Utility<Name> = {
						type: "utility",
						name,
						value: key,
						declarations: {},
						variables: [],
						children: [],
						modifiers: [],
					};

					const callbackContext = createDeclarationsCallbackContext(
						instance,
						root,
					);

					instance.declarations =
						factory({
							...callbackContext,
							value,
						}) ?? {};

					parseDeclarationsBlock(instance.declarations, callbackContext);

					if (!existingEntry) {
						factoryInstance.values.push({
							key,
							value,
							modifiers: [],
						});

						// Store the utility value on the instance
						parent.children.push(instance);
					}

					// Create modified variants for this specific value
					if (modifiers && modifiers.length > 0) {
						const modifierKeys = modifiers.map((modifier) => modifier.key);
						const modifierKeyCombinations = combineKeys(modifierKeys);

						const modifiedEntries = modifierKeyCombinations
							.filter((combination) => {
								// Check for duplicate keys without modifiers
								return !factoryInstance.values.find(
									(entry) =>
										entry.key === key &&
										entry.modifiers.length === combination.length &&
										entry.modifiers.every((mod) => combination.includes(mod)),
								);
							})
							.reduce<Utility[]>((acc, combination) => {
								const modifiersByKey = new Map<string, ModifierFactory>();
								for (const modKey of combination) {
									const modifier = modifiers.find((modifier) =>
										modifier.key.includes(modKey),
									);

									if (modifier && isModifier(modifier)) {
										modifiersByKey.set(modKey, modifier);
									}
								}

								factoryInstance.values.push({
									key,
									value,
									modifiers: combination,
								});

								acc.push(applyModifiers(instance, root, modifiersByKey));

								return acc;
							}, []);

						parent.children.push(...modifiedEntries);
					}
				}
			},
		};

		root.utilities.push(factoryInstance);

		return factoryInstance.create;
	};
}
