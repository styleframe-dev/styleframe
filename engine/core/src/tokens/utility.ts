import { transformUtilityKey } from "../defaults";
import { isModifier, isRef } from "../typeGuards";
import type {
	Container,
	ModifierFactory,
	Root,
	Utility,
	UtilityAutogenerateFn,
	UtilityCallbackFn,
	UtilityCreatorFn,
	UtilityFactory,
} from "../types";
import {
	createDeclarationsCallbackContext,
	parseDeclarationsBlock,
} from "./declarations";
import { applyModifiers, combineKeys } from "./modifier";

export function createUtilityFunction(parent: Container, root: Root) {
	return function utility<Name extends string>(
		name: Name,
		factory: UtilityCallbackFn,
		options: { autogenerate?: UtilityAutogenerateFn; namespace?: string } = {},
	): UtilityCreatorFn {
		const factoryInstance: UtilityFactory<Name> = {
			type: "utility",
			name,
			factory,
			values: [],
			autogenerate:
				options.autogenerate ??
				transformUtilityKey(
					options.namespace ? { namespace: options.namespace } : undefined,
				),
			namespace: options.namespace,
			create: (entries, modifiers = []) => {
				let resolvedEntries = entries;

				if (Array.isArray(entries)) {
					/**
					 * If entries is an array, convert it to an object with relevant keys and values
					 *
					 * @example Arbitrary value: ['red'] => { '[red]': 'red' }
					 * @example Token reference: ['@color.primary'] => { 'color.primary': ref('color.primary') }
					 * @example Token reference with replacement: ['@color.primary'] => { 'primary': ref('color.primary') }
					 */
					resolvedEntries = {};

					for (const value of entries) {
						const autogeneratedEntries = factoryInstance.autogenerate(value);

						resolvedEntries = {
							...resolvedEntries,
							...autogeneratedEntries,
						};
					}
				}

				for (const [key, entryValue] of Object.entries(resolvedEntries)) {
					const value =
						factoryInstance.namespace &&
						isRef(entryValue) &&
						!root.variables.some((v) => v.name === entryValue.name)
							? key
							: entryValue;

					const existingEntry = factoryInstance.values.find(
						(entry) => entry.key === key && entry.modifiers.length === 0,
					);

					const instance: Utility<Name> = {
						type: "utility",
						name,
						value: key,
						declarations: {},
						variables: [],
						children: [],
						modifiers: [],
					};

					const callbackContext = createDeclarationsCallbackContext(
						instance,
						root,
					);

					instance.declarations =
						factory({
							...callbackContext,
							value,
						}) ?? {};

					parseDeclarationsBlock(instance.declarations, callbackContext);

					if (!existingEntry) {
						factoryInstance.values.push({
							key,
							value,
							modifiers: [],
						});

						// Store the utility value on the instance
						parent.children.push(instance);
					}

					// Create modified variants for this specific value
					if (modifiers && modifiers.length > 0) {
						const modifierKeys = modifiers.map((modifier) => modifier.key);
						const modifierKeyCombinations = combineKeys(modifierKeys);

						const modifiedEntries = modifierKeyCombinations
							.filter((combination) => {
								// Check for duplicate keys without modifiers
								return !factoryInstance.values.find(
									(entry) =>
										entry.key === key &&
										entry.modifiers.length === combination.length &&
										entry.modifiers.every((mod) => combination.includes(mod)),
								);
							})
							.reduce<Utility[]>((acc, combination) => {
								const modifiersByKey = new Map<string, ModifierFactory>();
								for (const modKey of combination) {
									const modifier = modifiers.find((modifier) =>
										modifier.key.includes(modKey),
									);

									if (modifier && isModifier(modifier)) {
										modifiersByKey.set(modKey, modifier);
									}
								}

								factoryInstance.values.push({
									key,
									value,
									modifiers: combination,
								});

								acc.push(applyModifiers(instance, root, modifiersByKey));

								return acc;
							}, []);

						parent.children.push(...modifiedEntries);
					}
				}
			},
		};

		root.utilities.push(factoryInstance);

		return factoryInstance.create;
	};
}
