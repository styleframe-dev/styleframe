---
title: Variables
description: Styleframe variables are the foundation of your design system. They let you define design tokens such as colors, spacing, typography, and more. 
navigation:
  icon: i-lucide-variable
---

## Overview

Variables are the foundation of your design system. They let you define design tokens such as colors, spacing, typography, and more, with full type safety and auto-complete. Variables are reusable, composable, and become CSS custom properties in your generated styles.

## Why use variables?

Variables help you:

- **Centralize your design decisions**: Define a color, spacing value, or font once, and reference it everywhere.
- **Enable easy theming**: Quickly override variables to create dark mode, brand themes, or user personalization.
- **Prevent mistakes**: Change a value in one place, update your whole app &mdash; with zero risk of typos or missed selectors.

## Defining Variables

You define a variable using the `variable()` function from your styleframe instance:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable } = s;

const colorPrimary = variable('color.primary', '#006cff');
const spacingMd = variable('spacing.md', '1rem');

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--primary: #006cff;
    --spacing--md: 1rem;
}
```

:::
::

Each variable gets a **name** (used for the CSS custom property) and a **value**.

### Naming Convention (Dot Notation)

Styleframe allows you to use the **dot notation** for variable names, which provides a clean, readable way to organize your design tokens into logical groups. When compiled to CSS, dots (`.`) are automatically converted to double dashes (`--`).

| Variable Name | CSS Custom Property |
|---------------|---------------------|
| `color.primary` | `--color--primary` |
| `spacing.md` | `--spacing--md` |
| `font.size.lg` | `--font--size--lg` |
| `border.radius.sm` | `--border--radius--sm` |

::tip
**Pro tip:** The conversion can be customized via the [configuration options](/docs/api/instance#configuration-options) if needed, but the default behavior is designed to balance readability in code with valid CSS syntax.
::

### Why Dot Notation?

- **Readability**: Dots are more natural to read and type than double dashes in JavaScript/TypeScript code.
- **Namespacing**: Easily group related variables (e.g. `color.primary`, `color.secondary`, `color.accent`).
- **Autocomplete-friendly**: IDEs can provide better autocomplete suggestions for dot-separated names.
- **CSS Compatibility**: The compiled double-dash format (e.g. `--color--primary`) is valid CSS and clearly distinguishes namespace separators from the standard `--` prefix.

## Default Values

You can also define a variable with a default value. The default value will be used only if the variable is not already defined in the styleframe instance:


::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable } = s;

function useDefaultVariables() {
    variable('spacing', '1rem', { default: true }); 
}

variable('spacing', '2rem');

useDefaultVariables(); // This will not override the previous value

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --spacing: 2rem;
}
```

:::
::

::tip

Using default values is useful when working with [Composables](/docs/api/composables) which are likely to get called multiple times, or when you want to ensure a variable has a fallback value if not set elsewhere.

::

## Referencing Variables

To use a variable in other style definitions, pass its reference using the `ref()` helper:

### a. Within Variables

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref } = s; 

const colorBlue = variable('color.blue', '#006cff')

const colorPrimary = variable('color.primary', ref(colorBlue));

export default s;

```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--blue: #006cff;
    --color--primary: var(--color--blue);
}
```

:::
::

### b. Within Selectors


::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref, selector } = s;

const colorPrimary = variable('color.primary', '#006cff');

selector('.button', {
    backgroundColor: ref(colorPrimary),
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--primary: #006cff;
}

.button {
    background-color: var(--color--primary);
}
```

:::
::

This tells styleframe to inject the actual variable value (as a CSS custom property) in the generated CSS.

## Referencing Variables with Fallback Values

You can also provide a fallback value when referencing a variable. This is useful if you want to ensure a default value is used if the variable is not defined:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref } = s;

const colorSecondary = variable(
    'color.secondary', 
    ref('color.purple', '#ff5733') // Fallback to #ff5733 if not defined
);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--primary: #006cff;
    --color--secondary: var(--color--primary, #ff5733);
}
```

:::
::

## Best Practices

- **Use variables for all design tokens** (colors, font sizes, spacing, radii, etc.).
- **Avoid hardcoding values in selectors**, always referencing a variable where possible.
- **Group related variables** in separate files with composables for clarity (e.g., `useColors`, `useSpacing`).
- **Document your variable choices** for your team &mdash; explain why you chose certain values.

## FAQ

::accordion

:::accordion-item{label="What happens if I define the same variable name twice?" icon="i-lucide-circle-help"}
By default, the second definition will override the first. However, if you use the option, the variable will only be set if it doesn't already exist, preventing accidental overwrites. `{ default: true }`
:::

:::accordion-item{label="Can I use variables in media queries and keyframes?" icon="i-lucide-circle-help"}
Yes! Variables work seamlessly in media queries, keyframes, and any other CSS context. Use `ref(variable)` to reference them anywhere in your styles.
:::

:::accordion-item{label="Can I create computed or derived variables?" icon="i-lucide-circle-help"}
Absolutely! You can reference other variables using to create computed values, or use the [`css` template literal](/docs/api/interpolation) for complex calculations.
:::

:::accordion-item{label="What's the difference between hardcoding values and using variables?" icon="i-lucide-circle-help"}
Variables enable theming, consistency, and maintainability. They become CSS custom properties that can be dynamically changed at runtime, while hardcoded values are static and require rebuilding to change.
:::

:::accordion-item{label="How do variable names get converted to CSS custom properties?" icon="i-lucide-circle-help"}
Styleframe uses dot notation for variable names and converts them to CSS custom properties by:
1. Prefixing the name with `--`
2. Converting all dots (`.`) to double dashes (`--`)

For example, a variable named `color.primary` becomes `--color--primary` in the generated CSS. This convention keeps your JavaScript/TypeScript code clean while producing valid, well-namespaced CSS custom properties.
:::
::
