---
title: Selectors
description: Styleframe selectors allow you to create CSS rules with type-safe property definitions. They provide a powerful way to style your components.
navigation:
  icon: i-lucide-scan-text
---

## Overview

Selectors are the core building blocks for creating styles in Styleframe. They allow you to define CSS rules with full type safety and auto-complete. Selectors can target HTML elements, classes, IDs, and use any valid CSS selector syntax while providing a clean TypeScript API for defining styles.

## Why use selectors?

Selectors help you:

- **Write type-safe CSS**: Get auto-complete and instant feedback in your editor for all CSS properties and values.
- **Prevent common mistakes**: Eliminate typos and invalid CSS at compile time, before it hits the browser.
- **Compose styles with ease**: Leverage variables and composables for reusable, scalable design patterns.
- **Generate clean, optimized output**: Let Styleframe handle the generation of clean, optimized CSS output.

## Defining Selectors

You define a selector using the `selector()` function from your styleframe instance:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { selector } = s;

selector('.button', {
    padding: '0.5rem 1rem',
    borderRadius: '4px',
    backgroundColor: '#006cff',
    color: 'white',
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.button {
    padding: 0.5rem 1rem;
    border-radius: 4px;
    background-color: #006cff;
    color: white;
}
```

:::
::

Each selector takes a **CSS selector string** and a **style declarations object** with the properties and values you want to apply.

::tip

**Pro tip:** Use descriptive class names that reflect the component's purpose rather than its appearance. This makes your CSS more maintainable.

::

## Nested Selectors

You can nest selectors to create more specific targeting and improve readability:

### a. Callback Nesting

For more complex nesting scenarios or when you need to generate selectors dynamically, you can use the callback-based approach.


::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { selector } = s;

const nested = selector('.card', ({ selector }) => {
    selector('.card-title', {
        fontSize: '1.5rem',
        fontWeight: 'bold',
    });

    selector('.card-content', {
        marginTop: '0.5rem',
    });
    
    return {
        padding: '1rem',
        borderRadius: '8px'
    }
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.card {
    padding: 1rem;
    border-radius: 8px;

    .card-title {
        font-size: 1.5rem;
        font-weight: bold;
    }

    .card-content {
        margin-top: 0.5rem;
    }
}
```

:::
::

When using the callback-based approach, you can return a style declarations object to apply to the parent selector.

### b. Inline Nesting
Alternatively, you can use inline nesting syntax for simpler nested selector definitions:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { selector } = s;

selector('.card', {
    padding: '1rem',
    borderRadius: '8px',

    '.card-title': {
        fontSize: '1.5rem',
        fontWeight: 'bold'
    },

    '.card-content': {
        marginTop: '0.5rem'
    }
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.card {
    padding: 1rem;
    border-radius: 8px;

    .card-title {
        font-size: 1.5rem;
        font-weight: bold;
    }

    .card-content {
        margin-top: 0.5rem;
    }
}
```

:::
::

## Examples

### Pseudo Classes and Elements

Styleframe supports all CSS pseudo-classes and pseudo-elements, as well as the new `&` nesting selector:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { selector } = s;

selector('.button', {
    padding: '0.5rem 1rem',
    backgroundColor: '#006cff',
    color: 'white',
    transition: 'background-color 0.2s',
    
    '&:hover': {
        backgroundColor: '#0056cc',
    },
    
    '&:active': {
        backgroundColor: '#004099',
    },
    
    '&::before': {
        content: '""',
        display: 'inline-block',
        marginRight: '0.5rem',
    },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.button {
    padding: 0.5rem 1rem;
    background-color: #006cff;
    color: white;
    transition: background-color 0.2s;

    &:hover {
        background-color: #0056cc;
    }

    &:active {
        background-color: #004099;
    }

    &::before {
        content: "";
        display: inline-block;
        margin-right: 0.5rem;
    }
}
```

:::
::


### Using Variables with Selectors

To create a cohesive design system, combine selectors with variables:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, ref, selector } = s;

const borderRadiusSm = variable('border-radius.sm', '4px');
const colorPrimary500 = variable('color.primary', '#006cff');
const colorPrimary600 = variable('color.primary-dark', '#0056cc');
const spacingMd = variable('spacing.md', '1rem');

selector('.button', {
    backgroundColor: ref(colorPrimary500),
    borderRadius: ref(borderRadiusSm),
    color: 'white',
    padding: ref(spacingMd),
    
    '&:hover': {
        backgroundColor: ref(colorPrimary600),
    },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --border-radius--sm: 4px;
    --color--primary-500: #006cff;
    --color--primary-600: #0056cc;
    --spacing--md: 1rem;
}

.button {
    background-color: var(--color--primary-500);
    border-radius: var(--border-radius--sm);
    color: white;
    padding: var(--spacing--md);
    
    &:hover {
        background-color: var(--color--primary-600);
    }
}
```

:::
::

### Using @ Token References

For a more concise syntax, you can reference variables directly by their token path using the `@` prefix shorthand:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from 'styleframe';

const s = styleframe();
const { selector } = s;

selector('.button', {
    backgroundColor: "@color.primary",
    borderRadius: "@border-radius.sm",
    padding: "@spacing.md",

    '&:hover': {
        backgroundColor: "@color.primary-dark",
    },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.button {
    background-color: var(--color--primary);
    border-radius: var(--border-radius--sm);
    padding: var(--spacing--md);

    &:hover {
        background-color: var(--color--primary-dark);
    }
}
```

:::
::

The `@` prefix is a shorthand for the `ref()` function â€” `"@color.primary"` is equivalent to `ref('color.primary')`. It resolves the token path to a CSS custom property reference at compile time.

## Best Practices

- **Group related selectors** logically, either by component or functionality.
- **Use variables for values** that might be reused or could change in the future.
- **Keep selectors focused** on a single responsibility to improve maintainability.
- **Use descriptive class names** that indicate purpose rather than appearance.
- **Leverage nesting** for better organization, but avoid excessive nesting depths.

## FAQ

::accordion

:::accordion-item{label="Can I use any valid CSS selector?" icon="i-lucide-circle-help"}
Yes, any selector that works in CSS will work in Styleframe, including combinators, attribute selectors, and more.
:::

:::accordion-item{label="How do I handle vendor prefixes?" icon="i-lucide-circle-help"}
Styleframe can be integrated with tools like PostCSS/Autoprefixer to add vendor prefixes automatically, based on your configuration.
:::

:::accordion-item{label="Can I generate selectors dynamically?" icon="i-lucide-circle-help"}
Yes, you can use JavaScript/TypeScript to programmatically create selectors based on your needs.
:::

:::accordion-item{label="How do I override styles in specific contexts?" icon="i-lucide-circle-help"}
Use more specific selectors or leverage CSS specificity rules just as you would in regular CSS.
:::

::
