---
title: Recipes
description: Styleframe recipes provide powerful component variants with type-safe configuration options. Create flexible, reusable UI components with consistent styling patterns and runtime variant selection.
navigation:
    icon: i-lucide-chef-hat
---

## Overview

Recipes in Styleframe are advanced component styling systems that combine utility declarations with configurable variants. They provide a powerful way to create flexible, reusable UI components with type-safe variant selection, default configurations, and compound variant support for complex styling scenarios.

## Why use recipes?

Recipes help you:

- **Create consistent component variants**: Define utility declarations and systematic variations for buttons, cards, inputs, and other UI components.
- **Enable flexible configuration**: Provide multiple variant axes (size, color, state) that can be combined in any way your design system requires.
- **Maintain type safety**: Get full TypeScript support for variant names and values, preventing invalid combinations at compile time.
- **Support complex scenarios**: Use compound variants to handle specific combinations that need special styling treatment.

## How Recipes Work

When you define a recipe, Styleframe generates a function that you can call with variant props. This function returns a string of utility class names based on your configuration.

```ts [styleframe.config.ts]
// Define once in your config
recipe({
    name: "button",
    base: { padding: ref(spacingMd) },
    variants: {
        color: {
            primary: { background: ref(colorPrimary) },
            secondary: { background: ref(colorSecondary) },
        },
    },
});
```

```ts [src/components/Button.tsx]
import { button } from "virtual:styleframe";

// Use in your components
button({ color: "primary" })
// → "button _padding:md _background:primary"

button({ color: "secondary" })
// → "button _padding:md _background:secondary"
```

The recipe function handles all the logic of combining base styles with your selected variants, so you just pass in the props you want.

## Understanding the Runtime Package

::note
**Important**: Styleframe generates static CSS by default with zero runtime overhead. The TypeScript runtime package is only generated if you use recipes for dynamic variant selection.
::

The `@styleframe/runtime` runtime package provides lightweight functions that power recipe variant selection. It's tree-shakeable, so you only import what you use.


## How Recipe Fields Connect to Utilities

Each field in a recipe corresponds to a defined utility, and each value maps to a utility class suffix. Understanding this connection is key to using recipes effectively.

### Field Names are Utility Names

Recipe field names (in camelCase) map directly to your defined utilities:

| Recipe Field | Utility Name |
|--------------|--------------|
| `borderWidth` | `border-width` |
| `backgroundColor` | `background-color` |
| `padding` | `padding` |
| `fontSize` | `font-size` |

### Value Types and Class Suffixes

There are three ways to specify values in recipes, each producing different class suffixes:

#### 1. Token References using `ref()`

Use `ref()` to reference a token variable. The variable name becomes the class suffix.

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, recipe } = s;

const colorPrimary = variable("color.primary", "#3b82f6");
const colorWhite = variable("color.white", "#ffffff");

recipe({
    name: "button",
    base: {
        background: ref(colorPrimary),  // _background:primary
        color: ref(colorWhite),         // _color:white
    },
});
```

#### 2. Token Paths using `@token.path`

Use `@` prefix to reference a token by its path. The token name becomes the class suffix.

```ts [styleframe.config.ts]
recipe({
    name: "card",
    base: {
        background: "@color.surface",    // _background:surface
        padding: "@spacing.md",          // _padding:md
        borderRadius: "@radius.lg",      // _border-radius:lg
    },
});
```

#### 3. Arbitrary Values

Any value that isn't a token reference is treated as an arbitrary value and wrapped in brackets.

```ts [styleframe.config.ts]
recipe({
    name: "custom",
    base: {
        padding: "1rem",           // _padding:[1rem]
        fontSize: "14px",          // _font-size:[14px]
        cursor: "not-allowed",     // _cursor:[not-allowed]
    },
});
```

## How Classes Are Generated

Understanding the class naming convention helps you debug and understand the generated output.

::note
**Good to know**: The class suffix is determined by the utility's `autogenerate` function. You can customize this behavior when defining utilities. See [Utilities - Custom Auto-generate Function](/docs/api/utilities#custom-auto-generate-function) for details.
::

### Class Name Format

```
_[modifier:]utility-name:value
```

| Component | Description | Example |
|-----------|-------------|---------|
| `_` | Utility class prefix | `_` |
| `modifier:` | Optional modifier(s) | `hover:`, `focus:`, `hover:focus:` |
| `utility-name` | Kebab-case utility name | `border-width`, `padding` |
| `:value` | The resolved value key | `:primary`, `:md`, `:[1rem]` |

### Example Class Generation

Given this recipe:

```ts [styleframe.config.ts]
recipe({
    name: "button",
    base: {
        borderWidth: ref(borderWidthThin),  // Token reference
        borderStyle: "solid",                // Arbitrary value
        "hover:focus": {                     // Modifier block
            boxShadow: ref(boxShadowSm),
        },
    },
    variants: {
        color: {
            primary: {
                background: "@color.primary",
                color: "@color.white",
            },
        },
    },
});
```

The generated classes would be:

| Declaration | Generated Class |
|-------------|-----------------|
| `borderWidth: ref(borderWidthThin)` | `_border-width:thin` |
| `borderStyle: "solid"` | `_border-style:[solid]` |
| `hover:focus → boxShadow` | `_hover:focus:box-shadow:sm` |
| `background: "@color.primary"` | `_background:primary` |
| `color: "@color.white"` | `_color:white` |

## Defining Recipes

You define a recipe using the `recipe()` function from your styleframe instance:

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, utility, recipe } = s;

// Define your tokens
const borderWidthThin = variable("border-width.thin", "1px");
const colorPrimary = variable("color.primary", "#3b82f6");
const colorSecondary = variable("color.secondary", "#64748b");
const colorWhite = variable("color.white", "#ffffff");
const spacingSm = variable("spacing.sm", "0.5rem");
const spacingMd = variable("spacing.md", "1rem");
const spacingLg = variable("spacing.lg", "1.5rem");

// Define utilities that the recipe will use
utility("background", ({ value }) => ({ backgroundColor: value }));
utility("color", ({ value }) => ({ color: value }));
utility("padding", ({ value }) => ({ padding: value }));
utility("border-width", ({ value }) => ({ borderWidth: value }));
utility("border-style", ({ value }) => ({ borderStyle: value }));

// Define the recipe
recipe({
    name: "button",
    base: {
        borderWidth: ref(borderWidthThin),
        borderStyle: "solid",
    },
    variants: {
        color: {
            primary: {
                background: ref(colorPrimary),
                color: ref(colorWhite),
            },
            secondary: {
                background: ref(colorSecondary),
                color: ref(colorWhite),
            },
        },
        size: {
            sm: {
                padding: ref(spacingSm),
            },
            md: {
                padding: ref(spacingMd),
            },
            lg: {
                padding: ref(spacingLg),
            },
        },
    },
    defaultVariants: {
        color: "primary",
        size: "md",
    },
});

export default s;
```

### Recipe Options

The `recipe()` function accepts an options object with the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `name` | `string` | The recipe name (used as the base class) |
| `base` | `object` | Base declarations applied to all variants |
| `variants` | `object` | Variant groups with their options |
| `defaultVariants` | `object` | Default variant selections |
| `compoundVariants` | `array` | Conditional variant combinations |

## Using Modifiers in Recipes

You can apply modifiers (like `hover`, `focus`, etc.) to declarations within recipes:

```ts [styleframe.config.ts]
recipe({
    name: "button",
    base: {
        background: ref(colorPrimary),
        transition: "background 0.2s",
        // Apply hover and focus modifiers
        "hover": {
            background: ref(colorPrimaryDark),
        },
        "focus": {
            outline: "2px solid",
            outlineColor: ref(colorPrimary),
        },
        // Compound modifiers
        "hover:focus": {
            background: ref(colorPrimaryDarker),
        },
    },
});
```

This generates classes like:
- `_background:primary`
- `_hover:background:primary-dark`
- `_focus:outline:[2px solid]`
- `_hover:focus:background:primary-darker`

## Runtime Usage

Once defined, recipes are generated as functions that you can import and use in your components:

```ts [src/components/Button.tsx]
import { button } from "virtual:styleframe/recipes";

function Button({ color, size, children, ...props }) {
    // Generate class names based on variant props
    const className = button({ color, size });
    // Returns: "button _border-width:thin _border-style:[solid] _background:primary _color:white _padding:md"

    return (
        <button className={className} {...props}>
            {children}
        </button>
    );
}
```

### How Runtime Resolution Works

The runtime function:

1. Starts with the recipe name as the base class (`button`)
2. Adds all base declaration classes
3. For each variant, uses the prop value or falls back to `defaultVariants`
4. Resolves the variant option to its declaration classes
5. Applies compound variants if all match conditions are satisfied
6. Returns the combined class string

```ts [Example]
// With defaultVariants: { color: "primary", size: "md" }

button({})
// → "button _border-width:thin _border-style:[solid] _background:primary _color:white _padding:md"

button({ color: "secondary" })
// → "button _border-width:thin _border-style:[solid] _background:secondary _color:white _padding:md"

button({ color: "secondary", size: "lg" })
// → "button _border-width:thin _border-style:[solid] _background:secondary _color:white _padding:lg"
```

## Recipe Configuration

### Default Variants

Use `defaultVariants` to specify which variant should be applied when no explicit variant is chosen:

```ts [styleframe.config.ts]
recipe({
    name: "button",
    base: { /* ... */ },
    variants: {
        color: {
            primary: { /* ... */ },
            secondary: { /* ... */ },
        },
        size: {
            sm: { /* ... */ },
            md: { /* ... */ },
            lg: { /* ... */ },
        },
    },
    defaultVariants: {
        color: "primary",
        size: "md",
    },
});
```

### Compound Variants

Use `compoundVariants` to define special styling for specific variant combinations:

```ts [styleframe.config.ts]
recipe({
    name: "button",
    base: { /* ... */ },
    variants: {
        color: {
            primary: { /* ... */ },
            secondary: { /* ... */ },
        },
        disabled: {
            false: {},
            true: {
                opacity: "@opacity.50",
                cursor: "not-allowed",
            },
        },
    },
    compoundVariants: [
        {
            // When color is primary AND disabled is false
            match: {
                color: "primary",
                disabled: false,
            },
            css: {
                hover: {
                    background: "@color.primary-dark",
                },
            },
        },
        {
            // When color is secondary AND disabled is false
            match: {
                color: "secondary",
                disabled: false,
            },
            css: {
                hover: {
                    background: "@color.secondary-dark",
                },
            },
        },
    ],
});
```

Compound variants are applied only when **all** conditions in `match` are satisfied.

## Generated Output

When you run the Styleframe build, recipes generate:

### 1. CSS Utility Classes

All unique utility-value combinations found in the recipe are generated as CSS classes:

```css [Generated CSS]
._border-width\:thin { border-width: var(--border-width-thin); }
._border-style\:\[solid\] { border-style: solid; }
._background\:primary { background-color: var(--color-primary); }
._background\:secondary { background-color: var(--color-secondary); }
._color\:white { color: var(--color-white); }
._padding\:sm { padding: var(--spacing-sm); }
._padding\:md { padding: var(--spacing-md); }
._padding\:lg { padding: var(--spacing-lg); }
._hover\:background\:primary-dark:hover { background-color: var(--color-primary-dark); }
```

### 2. Runtime Recipe Functions

A TypeScript file with the recipe runtime:

```ts [Generated recipes.ts]
import { createRecipe } from "@styleframe/runtime";
import type { RecipeRuntime } from "@styleframe/runtime";

const buttonRecipe = {
    base: {
        borderWidth: "thin",
        borderStyle: "[solid]",
    },
    variants: {
        color: {
            primary: {
                background: "primary",
                color: "white",
            },
            secondary: {
                background: "secondary",
                color: "white",
            },
        },
        size: {
            sm: { padding: "sm" },
            md: { padding: "md" },
            lg: { padding: "lg" },
        },
    },
    defaultVariants: {
        color: "primary",
        size: "md",
    },
} as const satisfies RecipeRuntime;

export const button = createRecipe("button", buttonRecipe);
```

## Best Practices

- **Define utilities first**: Recipes reference utility names, so ensure your utilities are defined before creating recipes.
- **Use token references**: Prefer `ref()` or `@token.path` over arbitrary values for consistency with your design system.
- **Design systematic variants**: Create consistent naming and behavior patterns across all your recipe variants.
- **Use compound variants strategically**: Only create compound variants when the combination needs special handling beyond simple composition.
- **Provide sensible defaults**: Choose default variants that work well in most common use cases.
- **Keep variants focused**: Each variant axis should represent a single design dimension (size, color, state, etc.).

## FAQ

::accordion

:::accordion-item{label="Do I need the runtime package?" icon="i-lucide-circle-help"}
Only if you use recipes. The `@styleframe/runtime` package provides the `createRecipe` function that powers runtime variant selection. If you're only using utilities, you don't need it.
:::

:::accordion-item{label="How do recipes differ from utilities?" icon="i-lucide-circle-help"}
Utilities are individual CSS classes, while recipes are runtime functions that combine multiple utility classes based on variant props. Recipes are ideal for component-level styling systems where you need variant selection.
:::

:::accordion-item{label="Do recipes generate new CSS?" icon="i-lucide-circle-help"}
Recipes auto-generate the utility classes they need. The recipe runtime itself doesn't generate CSS—it returns strings of existing utility class names.
:::

:::accordion-item{label="How does this compare to CVA, Panda CSS, or Stitches?" icon="i-lucide-circle-help"}
Very similar! Recipes generate runtime functions that intelligently combine utility classes based on variant props, providing the same developer experience but tightly integrated with Styleframe's token and utility system.
:::

:::accordion-item{label="Can I use arbitrary values in recipes?" icon="i-lucide-circle-help"}
Yes! Any value that isn't a token reference is treated as an arbitrary value and wrapped in brackets (e.g., `"1rem"` becomes `_padding:[1rem]`).
:::

:::accordion-item{label="How are class names generated?" icon="i-lucide-circle-help"}
Class names follow the format `_[modifier:]utility-name:value`. The utility name is converted to kebab-case, and the value comes from the token name or is wrapped in brackets for arbitrary values.
:::

:::accordion-item{label="Can I use modifiers like hover and focus?" icon="i-lucide-circle-help"}
Yes! You can nest declarations under modifier keys like `"hover"`, `"focus"`, or compound modifiers like `"hover:focus"` to generate modifier-prefixed utility classes.
:::

::
