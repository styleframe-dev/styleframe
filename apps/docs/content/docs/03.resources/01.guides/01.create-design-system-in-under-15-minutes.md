---
title: Create a Design System in Under 15 Minutes
description: Build a complete, production-ready design system with Styleframe using composable design tokens. Follow this step-by-step guide to create colors, fluid typography, spacing, and more in just 15 minutes.
navigation:
    title: 15-Minute Design System
    icon: i-lucide-zap
---

Building a design system from scratch can be daunting. Between defining color palettes, typography scales, spacing systems, and component styles, it often takes weeks to get everything right.

**Not with Styleframe.** In this guide, you'll build a complete, production-ready design system in under 15 minutes using Styleframe's composable design tokens with fluid responsive typography.

::note
**What you'll build:** A cohesive design system with a full color palette (including automatic variants), fluid typography that scales smoothly across viewports, consistent spacing, border tokens, shadows, and responsive breakpoints‚Äîall type-safe and theme-ready.
::

## Prerequisites

Before starting, make sure you have:

- Node.js 18+ installed
- A project with Styleframe and Styleframe Pro installed ([Installation Guide](/docs/getting-started/installation/vite))
- Basic understanding of CSS and TypeScript

## Step 1: Foundation ‚Äì Colors (2 minutes)

Every great design system starts with colors. Let's create a comprehensive color system with automatic variants using the OKLCH color space.

#### Define Your Base Colors

Open your `styleframe.config.ts` and define your brand colors:

```ts
import { styleframe } from 'styleframe';
import { useColor, useColorLightness } from '@styleframe/theme';

const s = styleframe();

// Define your brand colors
const { colorPrimary, colorSecondary, colorGray } = useColor(s, {
    primary: '#0066ff',
    secondary: '#7c3aed',
    gray: '#64748b',
} as const);

// Define semantic colors
const { colorSuccess, colorWarning, colorDanger, colorInfo } = useColor(s, {
    success: '#10b981',
    warning: '#f59e0b',
    danger: '#ef4444',
    info: '#06b6d4',
} as const);

export default s;
```

#### Generate Automatic Color Variants

Now, automatically generate full lightness scales for each color:

```ts
// Generate lightness variants for primary color
const {
    colorPrimary50,
    colorPrimary100,
    colorPrimary200,
    colorPrimary300,
    colorPrimary400,
    colorPrimary500,
    colorPrimary600,
    colorPrimary700,
    colorPrimary800,
    colorPrimary900,
    colorPrimary950,
} = useColorLightness(s, colorPrimary);

// Generate lightness variants for gray (for UI backgrounds, borders, text)
const {
    colorGray50,
    colorGray100,
    colorGray200,
    colorGray300,
    colorGray400,
    colorGray500,
    colorGray600,
    colorGray700,
    colorGray800,
    colorGray900,
    colorGray950,
} = useColorLightness(s, colorGray);
```

**That's it!** You now have a complete color system with 11 variants per color, all perceptually uniform thanks to OKLCH. No manual color picking required.

::note
**Why OKLCH?** Unlike HSL, OKLCH maintains perceptual uniformity ‚Äî meaning lightness 50% actually looks halfway between black and white across all hues. This ensures your color scales look consistent.
::

## Step 2: Scales ‚Äì The Secret Sauce (1 minute)

Modular scales are the foundation of harmonious design systems. They use mathematical ratios to create proportional relationships between sizes.

For fluid typography, we'll define separate scales for mobile and desktop to optimize readability at different viewport sizes:

```ts
import { useScale, useScalePowers, defaultScaleValues } from '@styleframe/theme';

// Use Minor Third (1.2) for mobile, Major Third (1.25) for desktop
const { scaleMin, scaleMax } = useScale(s, {
    ...defaultScaleValues,
    min: '@minor-third',   // 1.2 - subtle scaling for small screens
    max: '@major-third',   // 1.25 - stronger hierarchy for large screens
});

// Generate scale powers from -3 to 5
// These will be multipliers for creating proportional sizes
const scaleMinPowers = useScalePowers(s, scaleMin, [-3, -2, -1, 0, 1, 2, 3, 4, 5]);
const scaleMaxPowers = useScalePowers(s, scaleMax, [-3, -2, -1, 0, 1, 2, 3, 4, 5]);
```

These scale powers will be used to create mathematically harmonious typography and spacing systems that adapt to viewport size.

::tip
**Scale Selection for Fluid Typography:**
- **Minor Third ‚Üí Major Third (1.2 ‚Üí 1.25)**: Balanced, works for most sites
- **Minor Third ‚Üí Perfect Fourth (1.2 ‚Üí 1.333)**: More dramatic hierarchy for desktop
- **Major Second ‚Üí Minor Third (1.125 ‚Üí 1.2)**: Subtle, great for dense content
- **Major Third ‚Üí Perfect Fourth (1.25 ‚Üí 1.333)**: Bold, ideal for marketing sites
::

## Step 3: Fluid Typography System (3 minutes)

With your scales defined, let's create a fluid typography system that scales smoothly across all viewport sizes ‚Äî no breakpoints needed!

#### Setup Fluid Viewport

First, establish the viewport range for fluid calculations:

```ts
import { useFluidViewport } from '@styleframe/pro';

// Set up fluid viewport (320px mobile ‚Üí 1440px desktop)
useFluidViewport(s);
```

This creates the foundation for all fluid design tokens. The composable automatically calculates a fluid breakpoint variable that represents the viewport's position between min and max widths.

#### Fluid Font Sizes with Modular Scales

Create font sizes that scale smoothly from mobile to desktop using your modular scales:

```ts
import { useFluidFontSize } from '@styleframe/pro';

// Generate fluid font sizes that scale from 16px‚Üí18px at the base
const {
    fontSize,
    fontSizeXs,    // Scale power -2: scales smoothly between mobile and desktop
    fontSizeSm,    // Scale power -1
    fontSizeMd,    // Scale power 0 (base size)
    fontSizeLg,    // Scale power 1
    fontSizeXl,    // Scale power 2
    fontSize2xl,   // Scale power 3
    fontSize3xl,   // Scale power 4
    fontSize4xl,   // Scale power 5
} = useFluidFontSize(
    s,
    { min: 16, max: 18 },  // Base font size: 16px mobile ‚Üí 18px desktop
    {
        xs: { min: scaleMinPowers[-2], max: scaleMaxPowers[-2] },
        sm: { min: scaleMinPowers[-1], max: scaleMaxPowers[-1] },
        md: { min: scaleMinPowers[0], max: scaleMaxPowers[0] },
        lg: { min: scaleMinPowers[1], max: scaleMaxPowers[1] },
        xl: { min: scaleMinPowers[2], max: scaleMaxPowers[2] },
        '2xl': { min: scaleMinPowers[3], max: scaleMaxPowers[3] },
        '3xl': { min: scaleMinPowers[4], max: scaleMaxPowers[4] },
        '4xl': { min: scaleMinPowers[5], max: scaleMaxPowers[5] },
        default: '@md',
    }
);
```

**The magic:** Each font size automatically scales between mobile and desktop using complex CSS `calc()` functions. Your h1 might go from 38px on mobile to 90px on desktop‚Äîsmoothly scaling at every viewport width in between!


#### Font Families

Define your font stacks:

```ts
import { useFontFamily, useFontWeight } from '@styleframe/theme';

const { fontFamily, fontFamilyMono, fontFamilyDisplay } = useFontFamily(s, {
    default: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    mono: '"SF Mono", Monaco, "Cascadia Code", "Roboto Mono", monospace',
    display: '"Inter Display", -apple-system, sans-serif',
} as const);

const { 
    fontWeightNormal, 
    fontWeightMedium, 
    fontWeightSemibold, 
    fontWeightBold 
} = useFontWeight(s);
```

#### Line Heights and Letter Spacing

Complete your typography system with optimal readability:

```ts
import { useLineHeight, useLetterSpacing } from '@styleframe/theme';

const {
    lineHeightTight,    // 1.25 - for headlines
    lineHeightNormal,   // 1.5 - for body text
    lineHeightRelaxed,  // 1.75 - for long-form content
} = useLineHeight(s);

const {
    letterSpacingTight,   // -0.025em - for large text
    letterSpacingNormal,  // 0 - standard
    letterSpacingWide,    // 0.025em - for small text/labels
} = useLetterSpacing(s);
```

## Step 4: Spacing System (1 minute)

Create consistent spacing using the same scale for visual harmony:

```ts
import { useSpacing, useMultiplier } from '@styleframe/theme';

// Define base spacing
const { spacing } = useSpacing(s, { default: '1rem' } as const);

// Generate spacing scale using the mobile scale for consistency
const {
    spacing3xs,  // ~0.579rem
    spacing2xs,  // ~0.694rem
    spacingXs,   // ~0.833rem
    spacingSm,   // ~0.833rem
    spacingMd,   // 1rem (base)
    spacingLg,   // ~1.2rem
    spacingXl,   // ~1.44rem
    spacing2xl,  // ~1.728rem
    spacing3xl,  // ~2.074rem
} = useMultiplier(s, spacing, {
    '3xs': scaleMinPowers[-3],
    '2xs': scaleMinPowers[-2],
    xs: scaleMinPowers[-1],
    sm: scaleMinPowers[-1],
    md: scaleMinPowers[0],
    lg: scaleMinPowers[1],
    xl: scaleMinPowers[2],
    '2xl': scaleMinPowers[3],
    '3xl': scaleMinPowers[4],
});
```

::tip
**Pro tip:** Using the same modular scale for spacing creates mathematical harmony with your typography. Everything feels proportionally connected!
::

## Step 5: Visual Depth (2 minutes)

Add borders, shadows, and breakpoints to complete your system.

#### Borders

```ts
import { useBorderWidth, useBorderStyle, useBorderColor } from '@styleframe/theme';

const { 
    borderWidth,
    borderWidthThin,
    borderWidthMedium,
    borderWidthThick,
} = useBorderWidth(s);

const { borderStyle } = useBorderStyle(s);

// Use your gray scale for border colors
const { 
    borderColor,
    borderColorLight,
    borderColorDark,
} = useBorderColor(s, {
    default: s.ref(colorGray300),
    light: s.ref(colorGray200),
    dark: s.ref(colorGray400),
} as const);
```

#### Box Shadows

Create an elevation system:

```ts
import { useBoxShadow } from '@styleframe/theme';

const {
    boxShadowSm,      // Subtle elevation
    boxShadow,        // Standard elevation
    boxShadowMd,      // Medium elevation
    boxShadowLg,      // High elevation
    boxShadowXl,      // Maximum elevation
} = useBoxShadow(s);
```

#### Responsive Breakpoints

Even with fluid typography, breakpoints are useful for layout changes:

```ts
import { useBreakpoint } from '@styleframe/theme';

const {
    breakpointXs,   // 0px - mobile
    breakpointSm,   // 576px - tablets
    breakpointMd,   // 992px - laptops
    breakpointLg,   // 1200px - desktops
    breakpointXl,   // 1440px - large screens
} = useBreakpoint(s);
```

## Step 6: Put It All Together

Here's your complete fluid design system in one place:

```ts
import { styleframe } from 'styleframe';
import {
    useColor,
    useColorLightness,
    useScale,
    useScalePowers,
    useFontFamily,
    useFontWeight,
    useLineHeight,
    useLetterSpacing,
    useSpacing,
    useBorderWidth,
    useBorderColor,
    useBoxShadow,
    useBreakpoint,
    useMultiplier,
    defaultScaleValues,
} from '@styleframe/theme';
import { useFluidViewport, useFluidFontSize } from '@styleframe/pro';

const s = styleframe();

// 1. Colors
const { colorPrimary, colorSecondary, colorGray } = useColor(s, {
    primary: '#0066ff',
    secondary: '#7c3aed',
    gray: '#64748b',
} as const);

const { colorSuccess, colorWarning, colorDanger, colorInfo } = useColor(s, {
    success: '#10b981',
    warning: '#f59e0b',
    danger: '#ef4444',
    info: '#06b6d4',
} as const);

// Generate color variants
// Generate lightness variants for primary color
const {
    colorPrimary50,
    colorPrimary100,
    colorPrimary200,
    colorPrimary300,
    colorPrimary400,
    colorPrimary500,
    colorPrimary600,
    colorPrimary700,
    colorPrimary800,
    colorPrimary900,
    colorPrimary950,
} = useColorLightness(s, colorPrimary);

// Generate lightness variants for gray (for UI backgrounds, borders, text)
const {
    colorGray50,
    colorGray100,
    colorGray200,
    colorGray300,
    colorGray400,
    colorGray500,
    colorGray600,
    colorGray700,
    colorGray800,
    colorGray900,
    colorGray950,
} = useColorLightness(s, colorGray);

// 2. Scales for Fluid Typography
const { scaleMin, scaleMax } = useScale(s, {
    ...defaultScaleValues,
    min: '@minor-third',   // 1.2 for mobile
    max: '@major-third',   // 1.25 for desktop
});

const scaleMinPowers = useScalePowers(s, scaleMin, [-3, -2, -1, 0, 1, 2, 3, 4, 5]);
const scaleMaxPowers = useScalePowers(s, scaleMax, [-3, -2, -1, 0, 1, 2, 3, 4, 5]);

// 3. Fluid Typography
useFluidViewport(s);

const { fontFamily, fontFamilyMono, fontFamilyDisplay } = useFontFamily(s, {
    default: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    mono: '"SF Mono", Monaco, "Cascadia Code", "Roboto Mono", monospace',
    display: '"Inter Display", -apple-system, sans-serif',
} as const);

const fontSizes = useFluidFontSize(
    s,
    { min: 16, max: 18 },
    {
        xs: { min: scaleMinPowers[-2], max: scaleMaxPowers[-2] },
        sm: { min: scaleMinPowers[-1], max: scaleMaxPowers[-1] },
        md: { min: scaleMinPowers[0], max: scaleMaxPowers[0] },
        lg: { min: scaleMinPowers[1], max: scaleMaxPowers[1] },
        xl: { min: scaleMinPowers[2], max: scaleMaxPowers[2] },
        '2xl': { min: scaleMinPowers[3], max: scaleMaxPowers[3] },
        '3xl': { min: scaleMinPowers[4], max: scaleMaxPowers[4] },
        '4xl': { min: scaleMinPowers[5], max: scaleMaxPowers[5] },
        default: '@md',
    }
);

const { fontWeight, fontWeightNormal, fontWeightMedium, fontWeightSemibold, fontWeightBold } = useFontWeight(s);
const { lineHeight, lineHeightTight, lineHeightNormal, lineHeightRelaxed } = useLineHeight(s);
const { letterSpacing, letterSpacingTight, letterSpacingNormal, letterSpacingWide } = useLetterSpacing(s);

// 4. Spacing
const { spacing } = useSpacing(s, { default: '1rem' } as const);
const spacings = useMultiplier(s, spacing, {
    '3xs': scaleMinPowers[-3],
    '2xs': scaleMinPowers[-2],
    xs: scaleMinPowers[-1],
    sm: scaleMinPowers[-1],
    md: scaleMinPowers[0],
    lg: scaleMinPowers[1],
    xl: scaleMinPowers[2],
    '2xl': scaleMinPowers[3],
    '3xl': scaleMinPowers[4],
});

// 5. Visual Depth

const { borderStyle } = useBorderStyle(s);

const { borderWidth, borderWidthThin, borderWidthMedium, borderWidthThick } = useBorderWidth(s);

const { borderColor, borderLight, borderColorDark } = useBorderColor(s, {
    default: s.ref(colorGray300),
    light: s.ref(colorGray200),
    dark: s.ref(colorGray400),
} as const);

const {  boxShadow, boxShadowSm, boxShadowMd, boxShadowLg, boxShadowXl } = useBoxShadow(s);

const { breakpointSm, breakpointMd, breakpointLg, breakpointXl } = useBreakpoint(s);

export default s;
```

## Next Steps: Components & Recipes

Your design system is complete! With these tokens in place, you're ready to build:

#### Components (Coming Soon)

Pre-built, customizable UI components that use your design tokens:
- Buttons (primary, secondary, outline, ghost variants)
- Forms (inputs, textareas, selects, checkboxes)
- Cards (with headers, footers, images)
- Modals & Dialogs
- Navigation (navbar, sidebar, breadcrumbs)
- Alerts & Notifications

#### Recipes (Coming Soon)

Common styling patterns and utilities:
- Layout patterns (stack, cluster, grid, sidebar)
- Text utilities (truncate, balance, gradient)
- State management (hover, focus, active, disabled)
- Dark mode theming
- Animation utilities


## Examples

### Using Your Design Tokens

Now that you've created your design system, let's use it to build some components!

#### Example: Button Component

```ts
const { ref, selector, css } = s;

selector('.btn', {
    fontFamily: ref(fontFamily),
    fontSize: ref(fontSize),
    fontWeight: ref(fontWeight),
    lineHeight: ref(lineHeight),
    
    paddingTop: ref(spacingSm),
    paddingBottom: ref(spacingSm),
    paddingLeft: ref(spacingMd),
    paddingRight: ref(spacingMd),
    
    borderRadius: '0.375rem',
    borderWidth: ref(borderWidth),
    borderStyle: ref(borderStyle),
    borderColor: ref(borderColor),
    backgroundColor: ref(colorPrimary),
    color: 'white',
    
    cursor: 'pointer',
    transition: 'all 0.2s ease',
});

selector('.btn:hover', {
    backgroundColor: ref(colorPrimaryShade50),
    boxShadow: ref(boxShadow),
});
```

## What Makes This Different?

Traditional design systems require:
- ‚ùå Manually defining dozens of color shades
- ‚ùå Creating multiple media queries for responsive typography
- ‚ùå Picking arbitrary font sizes at each breakpoint
- ‚ùå Inconsistent spacing values across your app
- ‚ùå Brittle, hard-coded CSS values
- ‚ùå Weeks of refinement to get proportions right

With Styleframe's fluid design system, you get:
- ‚úÖ **Automatic color variants** using perceptually uniform OKLCH
- ‚úÖ **Smooth responsive scaling** without breakpoints
- ‚úÖ **Mathematical harmony** through modular scales
- ‚úÖ **Type-safe tokens** with full autocomplete
- ‚úÖ **Theme-ready** from day one
- ‚úÖ **Production-ready** in under 15 minutes

## Key Takeaways

1. **Start with colors**: Define your brand colors and generate variants automatically
2. **Choose mobile and desktop scales**: Select modular scale ratios for each viewport size
3. **Enable fluid viewport**: Set up the foundation for fluid design tokens
4. **Create fluid typography**: Font sizes scale smoothly across all screen sizes
5. **Build systematic spacing**: Use the same scale for visual harmony
6. **Add depth**: Borders, shadows, and breakpoints complete the system
7. **Stay flexible**: All tokens can be overridden for themes or special cases

## Troubleshooting

::accordion

:::accordion-item{label="My fluid font sizes are too large/small" icon="i-lucide-circle-help"}
Adjust the base font size range in `useFluidFontSize()`. The `{ min: 16, max: 18 }` means your base text goes from 16px (mobile) to 18px (desktop). Try `{ min: 14, max: 16 }` for smaller text, or `{ min: 16, max: 20 }` for larger. All other sizes scale proportionally from this base!
:::

:::accordion-item{label="Typography doesn't scale enough between mobile and desktop" icon="i-lucide-circle-help"}
Use more dramatic scale ratios! Try `min: '@major-second'` (1.125) and `max: '@perfect-fourth'` (1.333) for stronger differences. Or go bold with `min: '@minor-third'` (1.2) and `max: '@perfect-fifth'` (1.5). Each step up the scale makes the size differences more pronounced.
:::

:::accordion-item{label="Can I use fixed sizes for some elements?" icon="i-lucide-circle-help"}
Absolutely! Mix `useFluidFontSize()` with regular `useFontSize()`. Use fluid sizes for headings and display text where scaling matters, and fixed sizes for UI elements like buttons and labels where consistency is more important.
:::

:::accordion-item{label="Colors don't match my brand guidelines exactly" icon="i-lucide-circle-help"}
That's fine! Use `useColor()` to define your exact brand colors, then let `useColorLightness()` generate the variants. The base color (500) will match your guidelines exactly, while variants provide flexibility for different UI states.
:::

:::accordion-item{label="How do I add more/fewer font sizes?" icon="i-lucide-circle-help"}
Adjust the range in `useScalePowers()`. For more sizes, use a wider range like `[-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6]`. For fewer, use `[-1, 0, 1, 2, 3]`. Then add or remove entries in the `useFluidFontSize()` size definitions. Remember: fewer choices often lead to better consistency.
:::

:::accordion-item{label="Can I use this with an existing design system?" icon="i-lucide-circle-help"}
Absolutely! Styleframe design tokens can complement an existing system. Start by migrating one area (like colors or typography) and gradually expand. The fluid tokens work alongside traditional CSS and can even wrap existing design token values.
:::

:::accordion-item{label="What if I don't have Styleframe Pro?" icon="i-lucide-circle-help"}
You can still build an amazing design system! Follow Steps 1, 2, 4, and 5 exactly as written. For Step 3 (Typography), use the fixed typography approach with `useFontSize()` and `useMultiplier()` instead of `useFluidFontSize()`. You'll have a great design system‚Äîjust with traditional responsive typography instead of fluid scaling.
:::

::

## Additional Resources

- [Fluid Design Overview](/docs/design-tokens/fluid-design) - Deep dive into fluid responsive design
- [Fluid Typography](/docs/design-tokens/fluid-design/typography) - Advanced fluid typography techniques
- [Colors Documentation](/docs/design-tokens/colors) - Advanced color techniques
- [Typography Documentation](/docs/design-tokens/typography) - Fixed typography systems
- [Scales Documentation](/docs/design-tokens/scales) - Understanding modular scales
- [Utopia Fluid Type Scale](https://utopia.fyi/) - The mathematical foundation

---

**Congratulations!** üéâ You've built a production-ready fluid design system in under 15 minutes. Your design tokens are type-safe, theme-ready, mathematically harmonious, and scale beautifully across all viewport sizes. Now go build something beautiful!
