---
title: Figma Plugin
description: Sync your Styleframe design tokens with Figma using the plugin and CLI commands for bidirectional token synchronization.
navigation:
  icon: i-simple-icons-figma
---

## Overview

The Styleframe Figma Plugin enables bidirectional synchronization of design tokens between your codebase and Figma. Export your Styleframe variables to Figma, or import Figma variables back into your codebase—all using the industry-standard W3C DTCG (Design Tokens Community Group) format.

**Key features:**

- **Code-first architecture**: Your Styleframe config is the single source of truth
- **Bidirectional sync**: Import tokens into Figma or export Figma variables to code
- **Multi-mode support**: Light, dark, and custom themes are preserved as Figma modes
- **Type-safe**: Colors, dimensions, strings, and booleans are mapped correctly
- **Free and open source**: No subscriptions or seat limits

## Prerequisites

Before you begin, ensure you have:

- A Styleframe project with design tokens defined
- A Figma account (free or paid)
- Node.js 18+ installed (for CLI commands)

## Installing the Figma Plugin

1. Visit the [Styleframe Sync plugin](https://www.figma.com/community/plugin/1597716416772135340/styleframe){target="_blank"} on the Figma Community
2. Click **"Open in..."** and select your Figma file
3. The plugin will appear in your Figma **Plugins** menu

::tip
**Pro tip:** Right-click in Figma and go to **Plugins > Styleframe** to quickly access the plugin.
::

---

## Using the Figma Plugin

The plugin has two tabs: **Import** for bringing tokens into Figma, and **Export** for extracting Figma variables.

### Importing Tokens into Figma

![Styleframe - Import Design Tokens into Figma](/assets/images/figma-import.png){.w-fit}

Import your Styleframe design tokens into Figma as native Figma Variables:

1. **Export your tokens** using the CLI (see [CLI Export](#exporting-tokens-code--figma) below)
2. **Open the plugin** in Figma and select the **Import** tab
3. **Drag and drop** your `tokens.json` file into the drop zone (or click to browse)
4. **Preview** the variables that will be created
5. Click **Import** to create the Figma variable collection

The plugin automatically:
- Creates a new variable collection with your tokens
- Sets up modes for each theme (Light, Dark, etc.)
- Maps token types to Figma variable types (Color, Number, String, Boolean)
- Preserves token aliases as Figma variable references

::note
If a collection with the same name already exists, variables will be updated rather than duplicated.
::

### Exporting Tokens from Figma

![Styleframe - Export Design Tokens from Figma](/assets/images/figma-export.png){.w-fit}

Export Figma Variables to the DTCG format for use in your codebase:

1. **Open the plugin** and select the **Export** tab
2. **Select a collection** from the dropdown menu
3. Click **Export** to generate the DTCG JSON
4. **Copy** the JSON to your clipboard or **Download** as a file
5. **Import into Styleframe** using the CLI (see [CLI Import](#importing-tokens-figma--code) below)

The export preserves:
- All variable values across modes
- Variable aliases as DTCG references (`{token.path}`)
- Token types and descriptions
- Hierarchical token structure

---

## Using the CLI

The Styleframe CLI provides commands for automating token synchronization in your development workflow.

### Exporting Tokens (Code → Figma)

Export your Styleframe variables to the DTCG format:

```bash
styleframe figma export [options]
```

| Option | Alias | Default | Description |
|--------|-------|---------|-------------|
| `--config` | `-c` | `styleframe.config.ts` | Path to Styleframe config file |
| `--output` | `-o` | `tokens.json` | Output JSON file path |
| `--collection` | `-n` | `Design Tokens` | Name for the Figma collection |
| `--baseFontSize` | - | `16` | Base font size for rem conversion |

**Example usage:**

```bash
# Basic export
styleframe figma export

# Custom config and output
styleframe figma export -c src/styleframe.config.ts -o design-tokens.json

# Named collection
styleframe figma export --collection "My Design System"
```

**Sample output:**

```bash
Loading configuration from "styleframe.config.ts"...
Extracting variables...
Writing 42 variables to "tokens.json"...
Exported 42 variables in DTCG format
```

### Importing Tokens (Figma → Code)

Generate Styleframe TypeScript code from a DTCG JSON file:

```bash
styleframe figma import --input <file> [options]
```

| Option | Alias | Default | Description |
|--------|-------|---------|-------------|
| `--input` | `-i` | *required* | Input DTCG JSON file path |
| `--output` | `-o` | `tokens.styleframe.ts` | Output TypeScript file path |
| `--composables` | - | `true` | Use @styleframe/theme composables |
| `--rem` | - | `false` | Use rem units for dimensions |
| `--baseFontSize` | - | `16` | Base font size for rem conversion |
| `--instanceName` | - | `s` | Styleframe instance variable name |

**Example usage:**

```bash
# Basic import
styleframe figma import -i tokens.json

# Custom output path
styleframe figma import -i tokens.json -o src/theme/tokens.ts

# With rem units
styleframe figma import -i tokens.json --rem --baseFontSize 16

# Without composables (plain variables)
styleframe figma import -i tokens.json --composables false
```

**Generated code example:**

```ts
import { styleframe } from "styleframe";
import { useColor, useSpacing } from "@styleframe/theme";

const s = styleframe();
const { variable, ref, theme } = s;

// Color variables
const { colorPrimary, colorSecondary } = useColor(s, {
  primary: "#006cff",
  secondary: "#6c757d",
});

// Spacing variables
const { spacingSm, spacingMd, spacingLg } = useSpacing(s, {
  sm: "8px",
  md: "16px",
  lg: "24px",
});

theme("dark", (ctx) => {
  ctx.variable(colorPrimary, "#60a5fa");
  ctx.variable(colorSecondary, "#9ca3af");
});

export default s;
```

---

## Recommended Workflow

Here's a typical workflow for syncing tokens between Styleframe and Figma:

### 1. Define tokens in Styleframe

```ts
// styleframe.config.ts
import { styleframe } from 'styleframe';

const s = styleframe();
const { variable, theme, ref } = s;

const colorPrimary = variable('color.primary', '#006cff');
const colorBackground = variable('color.background', '#ffffff');
const spacingMd = variable('spacing.md', '16px');

theme('dark', (ctx) => {
  ctx.variable(colorPrimary, '#60a5fa');
  ctx.variable(colorBackground, '#1a1a1a');
});

export default s;
```

### 2. Export to DTCG format

```bash
styleframe figma export -o tokens.json
```

### 3. Import into Figma

1. Open the Styleframe Sync plugin in Figma
2. Drag `tokens.json` into the Import tab
3. Click Import

### 4. Design in Figma

Use your variables in Figma as needed for components, styles, and layouts. 


## DTCG Format

Styleframe uses the W3C Design Tokens Community Group (DTCG) format for token interchange. This is an emerging standard supported by many design tools.

**Example DTCG structure:**

```json
{
  "$schema": "https://design-tokens.github.io/community-group/format/",
  "$extensions": {
    "dev.styleframe": {
      "collection": "Design Tokens",
      "modes": ["Light", "Dark"]
    }
  },
  "color": {
    "primary": {
      "$value": "#006cff",
      "$type": "color"
    },
    "background": {
      "$value": "#ffffff",
      "$type": "color"
    }
  },
  "$modifiers": {
    "theme": {
      "$type": "modifier",
      "contexts": {
        "Dark": {
          "color": {
            "primary": { "$value": "#60a5fa" },
            "background": { "$value": "#1a1a1a" }
          }
        }
      }
    }
  }
}
```

::tip
**Pro tip**: Learn more about the DTCG format at [designtokens.org](https://www.designtokens.org/){target="_blank"}.
::


## Best Practices

- **Keep code as the source of truth**: Define tokens in Styleframe first, then sync to Figma
- **Use semantic token names**: `color.primary` instead of `color.blue`
- **Organize with groups**: Use dot notation (`color.background.primary`) for hierarchy
- **Export tokens in CI/CD**: Automate `styleframe figma export` on every commit to generate fresh token files


## FAQ

::accordion

:::accordion-item{label="What token types are supported?" icon="i-lucide-circle-help"}
Styleframe supports four token types that map to Figma variable types:
- **Color**: CSS color values (hex, rgb, hsl, etc.) → Figma Color
- **Number/Dimension**: Numeric values with units (16px, 1rem) → Figma Number
- **String**: Text values → Figma String
- **Boolean**: true/false values → Figma Boolean
:::

:::accordion-item{label="How are themes/modes handled?" icon="i-lucide-circle-help"}
Styleframe themes become Figma modes. When you export tokens, the default theme becomes the first mode (usually "Light"), and each additional theme (like "dark") becomes a separate mode. Token overrides in themes are preserved as mode-specific values.
:::

:::accordion-item{label="Are variable aliases preserved?" icon="i-lucide-circle-help"}
Yes! When you export from Styleframe, token references using `ref()` are converted to DTCG alias syntax (`{token.path}`). When imported into Figma, these become native Figma variable references. The same applies in reverse when exporting from Figma.
:::

:::accordion-item{label="Can I use this with CI/CD pipelines?" icon="i-lucide-circle-help"}
Yes, the CLI is designed for automation. Add `styleframe figma export` to your build pipeline to generate fresh token files on every commit. Note that Figma's [Variables REST API](https://developers.figma.com/docs/rest-api/variables-endpoints/){target="_blank"} for programmatically importing tokens is only available to **Enterprise** organization members. For other plans, you'll need to use the plugin manually to import the generated JSON.
:::

:::accordion-item{label="What happens to existing Figma variables?" icon="i-lucide-circle-help"}
When importing tokens, the plugin updates existing variables with matching names rather than creating duplicates. New variables are added, and existing values are overwritten with the imported values.
:::

:::accordion-item{label="Is the plugin free?" icon="i-lucide-circle-help"}
Yes, the Figma plugin and CLI are completely free and open source. No subscriptions, no seat limits, no premium features hidden behind a paywall.
:::

::
