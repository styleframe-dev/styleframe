---
title: Styleframe vs. Vanilla Extract
description: Compare two zero-runtime, type-safe CSS-in-TypeScript approaches for large-scale design systems.
navigation:
  icon: i-lucide-scale
---

## Overview

Both **Styleframe** and **Vanilla Extract** generate **static CSS at build time** while letting you author styles in TypeScript. They share the same big benefits (zero runtime, type safety, SSR-friendly output), but they differ in **how much structure they provide out of the box**.

- **Styleframe**: design-system-first APIs (tokens, themes, utilities, recipes) with guided conventions.
- **Vanilla Extract**: a minimal, low-level core that you compose with additional packages/patterns as your system grows.

::tip
If your primary goal is **a scalable design-token + theming workflow** with consistent patterns across a team, Styleframe tends to require less “glue code” than a Vanilla Extract + utilities setup.
::

## At a glance

| Area | Styleframe | Vanilla Extract |
|---|---|---|
| Core philosophy | DS framework (tokens + patterns) | Minimal primitives (compose your own system) |
| Tokens | Built-in variable + composables approach | Themes/vars via contracts; tokens are DIY |
| Variants | Built-in `recipe()` | Add-on `@vanilla-extract/recipes` |
| Utilities / atomics | Built-in `utility()` patterns | Often via Sprinkles or custom utilities |
| DX onboarding | CLI-driven setup + conventions | Install + bundler plugin; conventions are up to you |
| Output | Static CSS (global or per-file) | Static CSS extracted from `.css.ts` |
| Best for | Large design systems, multi-team consistency | Teams wanting a thin, flexible base |

## Key differences

### Developer experience

#### Styleframe

- “Batteries included” workflow: design tokens, themes, variants, and utilities share one mental model.
- Convention-driven: common design system building blocks map to dedicated APIs (variables, composables, recipes).
- Works well when you want **consistent patterns across many contributors**.

#### Vanilla Extract

- Very approachable if you like working close to CSS concepts (typed style objects returning class names).
- You decide the architecture: tokens, variants, and utilities are assembled from core + ecosystem packages.
- Great for teams that want **maximum control** and don’t mind establishing internal conventions.

### Type safety and reliability

Both approaches are strongly typed because you author styles in TypeScript and extract to static CSS.

- Styleframe emphasizes **token references** (`variable()` + `ref()`) and composables that avoid accidental duplication via `default: true`.
- Vanilla Extract emphasizes **theme contracts** and typed `vars` usage, with additional type-safe helpers via ecosystem packages.

### API design and organization

#### Styleframe: “design system primitives”

Styleframe encourages you to structure a system around reusable building blocks:

- **Variables**: define tokens once; use everywhere.
- **Composables**: bundle related tokens/selectors/utilities into reusable modules.
- **Recipes**: model component variants (e.g., size, tone) with a type-safe runtime selector that outputs class names.

#### Vanilla Extract: “primitives + composition”

Vanilla Extract’s core APIs are intentionally small. Over time, many teams add:

- a theme contract + multiple themes,
- recipes for variants,
- sprinkles/atomic utilities (or your own abstractions),
- conventions for file placement and naming.

::note
If your goal is *“one coherent toolkit”* across tokens + themes + variants, Styleframe typically reduces the number of separate building blocks you need to adopt and document for your team.
::

## Feature deep dive

### Tokens and variables

Styleframe treats design tokens as first-class and promotes dot-notation naming that compiles to CSS custom properties.

::tabs
:::tabs-item{icon="i-lucide-code" label="Styleframe tokens (example)"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, selector } = s;

const colorPrimary = variable("color.primary", "#006cff");
const spacingMd = variable("spacing.md", "1rem");

selector(".button", {
  backgroundColor: ref(colorPrimary),
  padding: ref(spacingMd),
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
  --color--primary: #006cff;
  --spacing--md: 1rem;
}

.button {
  background-color: var(--color--primary);
  padding: var(--spacing--md);
}
```

:::
::

Vanilla Extract typically models tokens using theme contracts and `vars`, which you then reference in `style()` calls.

### Composables and reuse

Styleframe composables are a first-class pattern for packaging your design system into reusable modules (variables, selectors, utilities, recipes, themes).

- Prefer `use<Context>Variables` composables for token groups.
- Use `{ default: true }` to avoid accidental overrides when composables are called multiple times.

(See **Related docs** below for canonical composable patterns.)

### Variants and component recipes

Both ecosystems support type-safe variants, but Styleframe ships a recipe concept as part of the core “design system toolkit”, while Vanilla Extract typically pulls it in via `@vanilla-extract/recipes`.

### SSR and performance

Both are zero-runtime on the client:

- CSS is extracted at build time.
- SSR/SSG frameworks can serve HTML with classes already applied and CSS already linked/loaded.

## Choosing between them

### Choose Styleframe if…

- You’re building a **large-scale design system** with multiple token domains (color, spacing, typography, radii, etc.).
- You want **one consistent set of primitives** for tokens, themes, utilities, and variants.
- You expect many contributors and want conventions to be discoverable and enforced.

### Choose Vanilla Extract if…

- You want a very **minimal core** and prefer assembling only what you need.
- Your team already has established conventions for tokens/variants/utilities and doesn’t want additional abstraction.
- You’re optimizing for incremental adoption inside an existing codebase with established build tooling.

::tip
A practical heuristic: if you find yourself needing **tokens + themes + recipes + atomic utilities** on day 1, Styleframe tends to get you there with fewer moving parts.
::

## FAQ

::accordion

:::accordion-item{label="Do both approaches support theming (light/dark, brand themes)?" icon="i-lucide-circle-help"}
Yes. Both approaches typically compile themes to CSS variables scoped by a class/attribute. Styleframe provides a dedicated theming API integrated with variables, while Vanilla Extract commonly uses theme contracts + theme classes.
:::

:::accordion-item{label="Is there any runtime cost?" icon="i-lucide-circle-help"}
The generated styles are static CSS. The only “runtime” work in either approach is optional variant selection helpers (e.g., recipe functions) which generally resolve to class names.
:::

:::accordion-item{label="Can I mix global styles and per-component styles?" icon="i-lucide-circle-help"}
Yes. Both ecosystems can support a global entry stylesheet plus component-level extracted styles, depending on your build setup and how you organize modules.
:::

::
