---
title: Styleframe vs. Vanilla Extract
description: Compare two zero-runtime, type-safe CSS-in-TypeScript approaches for large-scale design systems.
navigation:
  icon: i-lucide-scale
---

## Overview

Frontend developers building large-scale design systems have an array of tools for managing CSS. Two modern approaches stand out for their **zero-runtime, type-safe philosophy**: Styleframe and Vanilla Extract. Both aim to improve the scalability and maintainability of styles, but they differ in developer experience, API design, and feature set.

Both **Styleframe** and **Vanilla Extract** generate **static CSS at build time** while letting you author styles in TypeScript. They share the same big benefits (zero runtime, type safety, SSR-friendly output), but they differ in **how much structure they provide out of the box**.

- **Styleframe**: design-system-first APIs (tokens, themes, utilities, recipes) with guided conventions. Offers a "first-class DX" including IDE autocompletion, in-editor documentation, and static analysis hooks.
- **Vanilla Extract**: a minimal, low-level core that you compose with additional packages/patterns as your system grows. Delivers a decent developer experience, but in a more "low-level" or unopinionated way.

::tip
If your primary goal is **a scalable design-token + theming workflow** with consistent patterns across a team, Styleframe tends to require less "glue code" than a Vanilla Extract + utilities setup.
::

## At a glance

| Area | Styleframe | Vanilla Extract |
|---|---|---|
| Core philosophy | DS framework (tokens + patterns) | Minimal primitives (compose your own system) |
| Tokens | Built-in variable + composables approach | Themes/vars via contracts; tokens are DIY |
| Variants | Built-in `recipe()` | Add-on `@vanilla-extract/recipes` |
| Utilities / atomics | Built-in `utility()` patterns | Often via Sprinkles or custom utilities |
| DX onboarding | CLI-driven setup + conventions | Install + bundler plugin; conventions are up to you |
| Output | Static CSS (global or per-file) | Static CSS extracted from `.css.ts` |
| Learning curve | Higher-level, more guided | Lower-level, shallow if you know CSS |
| Best for | Large design systems, multi-team consistency | Smaller projects or teams wanting a thin, flexible base |

## Key differences

### Developer experience

#### Styleframe

- **"Batteries included" workflow**: design tokens, themes, variants, and utilities share one mental model.
- **Convention-driven**: common design system building blocks map to dedicated APIs (variables, composables, recipes).
- Feels **high-level and structured** - you define your design tokens and styles in a central (or per-component) TypeScript file, and Styleframe's tooling generates the CSS.
- The framework-agnostic design further improves DX for teams working across React, Vue, Svelte, or other stacks.
- Works well when you want **consistent patterns across many contributors**.
- Styleframe's use of functions like `variable()` and `ref()` ensures a **checked linkage between tokens and their usage** - you can only `ref()` a variable that was actually defined.

#### Vanilla Extract

- Very approachable if you like working close to CSS concepts (typed style objects returning class names).
- You decide the architecture: tokens, variants, and utilities are assembled from core + ecosystem packages.
- Out of the box, it lets you write plain TypeScript objects to style elements, which many developers find intuitive - it's just like writing CSS, but in a typed context.
- The **learning curve is shallow** if you know CSS and basic TypeScript: you specify styles in plain objects and get back class name strings.
- Great for teams that don't mind establishing internal conventions.

### Type safety and reliability

Both approaches are strongly typed because you author styles in TypeScript and extract to static CSS. Both libraries eliminate the untyped "string-typed" nature of traditional CSS, but still allow the full expressiveness of CSS.

#### Styleframe

- Emphasizes **token references** (`variable()` + `ref()`) and composables that avoid accidental duplication via `default: true`.
- Styleframe's design token helpers come with **full auto-complete for token values**, meaning when you define a set of color tokens or spacing scales, those token names become literal types that the editor can suggest.
- This approach minimizes the chance of using an undefined token or an out-of-range value.
- Styleframe's type system enforces a consistent, error-free use of styles across your project.

#### Vanilla Extract

- Emphasizes **theme contracts** and typed `vars` usage, with additional type-safe helpers via ecosystem packages.
- Styles are written as typed objects, and you can define **contracts for design tokens (theme contracts)** that must be satisfied.
- When you use `createThemeContract` and `createTheme` to define design tokens, the library will require that any theme you create provides all the token keys, and it will provide typed `vars` to use in your styles - preventing mismatches.
- Type safety can be extended with community packages (for example, its Recipes package ensures only valid variant names are accepted in the theme functions).

::note
Both libraries give ground on compile-time reliability: developers can be confident that if their code compiles, the styles will work as intended. **Type safety is a core strength of both**, ensuring scalable systems with fewer runtime style bugs.
::

### API design and ease of use

#### Styleframe: structured, composable API

Styleframe provides a **structured, composable API** tailored to building design systems. At the center is a Styleframe instance (obtained by calling `styleframe()`), from which you destructure methods to define different aspects of your styles.

- `variable()` for defining design tokens
- `selector()` for registering styles for CSS selectors
- `utility()` for reusable utility classes
- `recipe()` for dynamic style variants

This separation is very **intentional** - it encourages you to think in terms of **design tokens and reusable patterns**. The API is **fluent and high-level**: you're often calling functions with semantic names rather than crafting raw style objects repeatedly.

Styleframe also provides **helper "composables"** for common design system pieces. For instance, you can import `useColor`, `useSpacing`, `useTypography`, etc., from the Styleframe theme package to quickly set up a palette or scale. These composables often generate not just one token, but a suite of related tokens - sometimes with automatic variants (like tints and shades for colors, or a fluid scale for typography). This **reduces boilerplate significantly** when setting up a design system.

Despite the rich API, Styleframe doesn't lock you into one file or one monolithic style definition. It supports **two usage patterns**: a single global `.styleframe.config.ts` file, or multiple per-component `.styleframe.ts` files, or even a mix of both.

#### Vanilla Extract: minimalist and close to CSS

Vanilla Extract's core API is **intentionally minimalist and close to CSS**. The primary functions you use are things like `style()` to create a class with a given style object, `globalStyle()` to define global CSS, `createVar()` and `assignVars()` to work with CSS Variables, and `createTheme()` (plus `createThemeContract`) for theming.

```ts
export const hero = style({
  backgroundColor: vars.color.brand,
  padding: vars.space.medium
});
```

This will generate a unique class (e.g., `.hero_xyz123`) and corresponding CSS. For developers familiar with CSS, this directness can feel comfortable - though there's still a learning curve for the various utility functions and patterns.

However, when your needs grow (as they often do in a large design system), you will likely need to introduce some structure. Vanilla Extract provides **escape hatches and addons**:

- **Theme contracts**: define a contract (essentially an object shape for tokens like colors and sizes) and then create themes that output a theme class plus a `vars` object to reference those tokens
- **Recipes package**: "heavily inspired by Stitches" provides a function to define multi-variant styles with a type-safe API

::tip
**Ease of use summary**: Styleframe's API is higher-level and more guided, which makes it easy to do complex things with little code (ideal for large design systems where consistency is key). Vanilla Extract's API is lower-level and flexible - easy to pick up initially, but requiring additional patterns or libraries to reach the same feature richness.
::

## Feature deep dive

### Tokens and variables

Styleframe treats design tokens as first-class and promotes dot-notation naming that compiles to CSS custom properties.

::tabs
:::tabs-item{icon="i-lucide-code" label="Styleframe tokens (example)"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, selector } = s;

const colorPrimary = variable("color.primary", "#006cff");
const spacingMd = variable("spacing.md", "1rem");

selector(".button", {
  backgroundColor: ref(colorPrimary),
  padding: ref(spacingMd),
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
  --color--primary: #006cff;
  --spacing--md: 1rem;
}

.button {
  background-color: var(--color--primary);
  padding: var(--spacing--md);
}
```

:::
::

Vanilla Extract typically models tokens using theme contracts and `vars`, which you then reference in `style()` calls. You can emulate a design token system by using `createGlobalThemeContract` and their values for different themes, though this requires more manual setup. Vanilla Extract fully supports CSS variables - you can create and assign CSS Vars freely, and even use them in advanced ways (like in selectors or media queries).

### Composables and reuse

Styleframe composables are a first-class pattern for packaging your design system into reusable modules (variables, selectors, utilities, recipes, themes).

- Prefer `use<Context>Variables` composables for token groups.
- Use `{ default: true }` to avoid accidental overrides when composables are called multiple times.

For instance, using `useColors`, `useSpacing`, `useTypography`, etc., from the Styleframe theme package quickly sets up a palette or scale. These composables often generate not just one token, but a suite of related tokens - sometimes with automatic variants (like tints and shades for colors).

This modularity is great for scaling up design systems (for example, sharing a common color palette across projects but each project defines its own spacing scale, etc.).

### Theming and multi-theme support

Both libraries treat theming as a first-class use case, but they handle it differently.

#### Styleframe

Has built-in theming APIs that make creating light/dark or custom themes straightforward. In a Styleframe config, you can call `theme("themename", callback)` to adjust tokens for that theme. For example, you might define a base theme with a primary color, then add `theme("dark", ctx => { ctx.variable(colorPrimary, "#60a5fa"); })` to override that color in dark mode.

Under the hood, this will produce CSS variables and classes that correspond to the themes (likely using a `[data-theme="dark"]` class or data attribute to scope the dark theme styles). Styleframe also allows **merging multiple theme files** and even composing themes (using different sets of tokens from different sources).

#### Vanilla Extract

Provides theming via its `createTheme` API. You define a theme contract (the shape of your design tokens) and then create one or more themes that fill in values for that contract, each theme giving you a unique `themeClass` to apply and a `vars` object for the token values. Switching theme in Vanilla Extract often means toggling the rendered `themeClass` on a parent element.

::note
Both approaches result in **zero-runtime theme switching** - it's just CSS classes and variables. Styleframe's approach might feel more integrated if you're already using its token APIs (since themes just tweak those tokens in one config), whereas Vanilla Extract's approach is more manual but also very clear in terms of output. **Both support multiple themes** with full type safety.
::

### Utility classes

Both libraries support atomic/utility-style CSS, but with different philosophies.

#### Styleframe

Provides a first-class `utility()` API that generates atomic utility classes from your design tokens. You define a utility factory once and then call it with token values to generate classes like `_margin:md` or `_padding:lg`.

```ts
const createMargin = utility('margin', ({ value }) => ({ margin: value }));
createMargin({ sm: ref(spacingSm), md: ref(spacingMd), lg: ref(spacingLg) });
```

Utilities in Styleframe are **deeply integrated with the token system** - they automatically use your defined variables and generate type-safe class names. You can also apply **modifiers** (like `hover`, `focus`, or responsive breakpoints) to utilities, producing classes like `_hover:background:primary` or `_md:padding:lg`.

The key advantage is that utilities, tokens, and recipes all share the same value system. When you change a spacing token, all utilities referencing it update automatically.

#### Vanilla Extract

Typically achieves atomic utilities through **Sprinkles**, an addon package (`@vanilla-extract/sprinkles`). With Sprinkles, you configure things like allowed spacing values, color values, and breakpoints, and it will produce utility classes and a typed API to apply them.

```ts
const sprinkles = createSprinkles(
  defineProperties({
    properties: {
      padding: vars.space,
      backgroundColor: vars.color
    }
  })
);
```

Sprinkles is powerful, but it's an extra configuration step and another library to learn. Styleframe essentially **builds the idea of Sprinkles into its core**, via `utility()` functions and token composables - giving you one integrated approach for tokens and utilities without additional setup.

### Variants and component recipes

Both ecosystems support type-safe variants, but Styleframe ships a recipe concept as part of the core "design system toolkit", while Vanilla Extract typically pulls it in via `@vanilla-extract/recipes`.

#### Styleframe

Addresses variants with its **Recipe API** (part of Styleframe's core). A recipe lets you define a component's base styles and a set of variants (with variant keys and possible values), and it outputs a **function** that you can use at runtime to get the correct class name.

Recipes and utilities in Styleframe are **tightly interconnected**. Both systems share the same design tokens, meaning a recipe variant can reference the same `ref(spacingMd)` value that your `_padding:md` utility uses. This ensures visual consistency whether you're applying atomic utilities or using component recipes. Additionally, you can combine recipe-generated classes with utility classes in your components - for example, using `button('color:primary')` alongside `_margin:lg` - without worrying about value mismatches since they derive from the same token definitions.

```ts
recipe({
  name: 'button',
  base: { padding: ref(spacingMd) },
  variants: {
    color: {
      primary: { background: ref(colorPrimary) },
      secondary: { background: ref(colorSecondary) }
    },
    size: {
      sm: { padding: '0.5rem' },
      lg: { padding: '1rem' }
    }
  }
});
```

This defines a button recipe with color and size variants. Styleframe will generate CSS classes for each combination and give you a `button()` function. Using `button('color:primary', 'size:lg')` in your component returns the class names implementing those styles. Importantly, this function is **typesafe** - you can only pick valid variant names and values (anything else would be a TypeScript error).

Styleframe recipes output **Tailwind-style atomic utility classes** that follow a consistent naming pattern. This means the generated classes are human-readable, easy to debug in DevTools, and blend seamlessly with your utility classes.

#### Vanilla Extract

Can achieve a similar outcome via the `@vanilla-extract/recipes` package. Using it, you can create something analogous to Styleframe's recipe - a function that accepts variant options and returns the appropriate class names. However, this requires installing and learning an additional package, whereas Styleframe includes this functionality out of the box.

A key difference is in **CSS output structure**. Vanilla Extract recipes generate **multiple separate classes** that get concatenated at runtime:

- One class for base styles (e.g., `.button__abc123`)
- One class per selected variant option (e.g., `.button_color_primary__def456`)
- Additional classes for compound variants (e.g., `.button_compound_0__ghi789`)

This means a single styled element might end up with several auto-generated class names like `button__abc123 button_color_primary__def456 button_size_large__jkl012`. While functional, these hashed class names can be harder to read and debug compared to Styleframe's predictable, semantic class names.

::note
Styleframe essentially **builds the idea of Sprinkles into its core**, via `utility()`, functions and token composables - giving you one integrated approach for tokens and utilities with cleaner, more debuggable output.
::

### SSR and performance

Both are zero-runtime on the client:

- CSS is extracted at build time.
- SSR/SSG frameworks can serve HTML with classes already applied and CSS already linked/loaded.

One of the initial motivations for both Styleframe and Vanilla Extract is to **avoid the runtime performance costs of CSS-in-JS solutions**. By generating actual CSS files or style tags at build time, both libraries ensure the rendering is **fast and SSR is supported out-of-the-box**.

#### Styleframe

Vite is the standard in modern frameworks. Styleframe provides a Vite plugin out-of-the-box and even adds it for you via the CLI in a Vite project. This means if you're using Vite (or a Vite-powered framework like Nuxt 3, SvelteKit, Astro, etc.), Styleframe is ready to go. Styleframe can be integrated into a Webpack or Rollup build, but the setup might be a bit more manual.

#### Vanilla Extract

Has the benefit of time here - it offers official plugins or guides for most environments: Webpack, Vite, Next.js, Parcel, esbuild, Remix, Gatsby and more are supported. For example, you can add `@vanilla-extract/vite-plugin` to Vite or use the Next.js `next-vanilla-extract` plugin for seamless integration. These plugins handle scanning your `.css.ts` files and extracting the CSS.

::note
In summary, Vanilla Extract currently has an edge in **documented compatibility** with a broad range of tools, simply due to maturity. **Styleframe is rapidly catching up** - it was designed to be agnostic and already works with many frameworks.
::

### Tooling and framework compatibility

Today's frontend ecosystem is rich, from bundlers (Webpack, Vite, esbuild) to frameworks (React, Vue, Svelte, Solid, Angular, etc.). A styling solution must **play nicely with the tools**.

- **Vanilla Extract** has the benefit of time here - it offers official plugins or guides for most environments. Setting up Vanilla Extract in a project involves installing it and configuring a bundler plugin (for Vite, Webpack, etc.), which is straightforward but not as automated as Styleframe's CLI.
- **Styleframe**, being newer, has focused on Vite (since Vite is increasingly the standard in modern frameworks). Styleframe provides a Vite plugin out-of-the-box and even adds it for you via the CLI. For other environments, Styleframe uses an "unplugin" under the hood - a technology that allows writing one plugin that works for multiple bundlers (Webpack, Rollup, esbuild, etc.).

Both tools are **framework-agnostic at runtime** - they simply output CSS classes you can use in any UI library. This means whether you're using React components or just vanilla JavaScript DOM manipulation, the result is the same: a class name string. **Neither is tied to React's runtime**, unlike some older CSS-in-JS libraries. This makes them suitable for design systems that need to be consumed by multiple frameworks.

## Why choose Styleframe over Vanilla Extract?

Both Styleframe and Vanilla Extract are **powerful, capable tools** for modern CSS management, and either can form the backbone of a large-scale design system. That said, there are specific reasons you might **favor Styleframe** for your project:

### All-in-one design system solution

Styleframe is essentially a *design system framework*, not just a styling utility. It comes with built-in support for **design tokens, themes, variants, and utilities** without piecing together multiple libraries. This means less configuration and more convention. If you want to rapidly build a scalable design system with minimal fuss, Styleframe provides the scaffolding - from light/dark theme switching to token scales - in one package.

Vanilla Extract, while flexible, would require combining core vanilla-extract with Sprinkles for tokens, perhaps custom scripts for fancy token math, and Recipes for variants. Styleframe's integrated approach can save development time and ensure consistency across all these aspects.

### Developer experience & maintainability

Styleframe was explicitly crafted with a decade of design system experience behind it. The result is an API that anticipates common needs of DS engineers (like mixing themes, generating variant palettes, enforcing token usage) and provides tools to address them in a type-safe way. The emphasis on **IDE integration and documentation directly in your editor** makes the developer experience **smooth and intuitive**.

In a large team, this translates to fewer styling bugs and a gentler learning curve for new contributors (they can leverage the self-documenting API and see clearly defined patterns). Vanilla Extract certainly improves on plain CSS or untyped CSS-in-JS, but Styleframe goes a step further in **nudging developers towards best practices** (for example, by making tokens and utilities the norm rather than hard-coded values).

### Composable and modular by nature

Styleframe promotes composition at every level - you compose styles from tokens, compose themes from sub-themes, compose utilities, etc. This modular design is a boon for large systems where you might share parts of the styling across multiple projects or packages.

For instance, you could have a base styleframe config for corporate branding and then extend or merge it with product-specific styles. Styleframe handles these merges elegantly (there's even a `merge()` helper for combining styleframe outputs).

If your goal is to build a **library of styling building blocks** that can be reused, Styleframe is designed for that scenario.

### Framework and team agnosticism

If your organization uses multiple frontend frameworks (say React for web app, Vue for some microsite, maybe even React Native in future - though neither library directly covers RN), Styleframe offers a unified approach that each team can adopt. You could have one design system team author the Styleframe configuration and each product team consumes the generated CSS (and recipe functions) in their framework of choice.

Vanilla Extract is also framework-agnostic in principle, but it's most commonly used in React or similar. It might require more convincing for, say, a Vue team to adopt Vanilla Extract, whereas Styleframe's framework-neutral branding (and examples across frameworks) could ease that adoption.

### Advanced features and future potential

Out of the box, Styleframe has some advanced capabilities that vanilla-extract lacks without custom work. For example, **automatic color shade generation, fluid responsive design utilities, and modern CSS features like OKLCH** are part of Styleframe's offering. This is a big plus if you want to leverage cutting-edge CSS techniques and have the library handle the heavy lifting.

Moreover, Styleframe's path towards AI integration could mean, in the near future, developers can use AI assistance to generate or refactor styles in a type-safe way (a unique value-add for teams wanting to speed up design system development).

## Choosing between them

### Choose Styleframe if…

- You're building a **large-scale design system** with multiple token domains (color, spacing, typography, radii, etc.).
- You want **one consistent set of primitives** for tokens, themes, utilities, and variants.
- You expect many contributors and want conventions to be discoverable and enforced.
- You value an **integrated, batteries-included approach** and want to accelerate building a maintainable design system with themes, design tokens, and variant management.
- Your design system demands numerous themes or runtime theme toggling.

### Choose Vanilla Extract if…

- You want a very **minimal core** and prefer assembling only what you need.
- Your team already has established conventions for tokens/variants/utilities and doesn't want additional abstraction.
- You're optimizing for **incremental adoption** inside an existing codebase with established build tooling.
- You prefer a lean core and the freedom to integrate only what you need.
- A project only needs static styles and a single theme.

::tip
A practical heuristic: if you find yourself needing **tokens + themes + recipes + atomic utilities** on day 1, Styleframe gets you there with fewer moving parts. For most frontend developers working with modern web stacks, especially when building or maintaining a **comprehensive design system**, Styleframe offers a compelling proposition: it provides more structure, more features out-of-the-box, and a **noticeably smoother DX** for the complete task of design system management.
::

## Conclusion

In conclusion, if you value an integrated, batteries-included approach and want to accelerate building a maintainable design system with themes, design tokens, and variant management, **Styleframe is an excellent choice**. It's especially advantageous for large projects where consistency and developer productivity are paramount.

**Vanilla Extract** remains a strong alternative if you prefer a minimalistic, piece-by-piece solution or if you're already invested in its ecosystem. Both will serve you well, but Styleframe's **developer experience and design-system-centric features** give it an edge for teams aiming to build the next generation of scalable, themeable, and future-proof frontend design systems.

## FAQ

::accordion

:::accordion-item{label="Do both approaches support theming (light/dark, brand themes)?" icon="i-lucide-circle-help"}
Yes. Both approaches typically compile themes to CSS variables scoped by a class/attribute. Styleframe provides a dedicated theming API integrated with variables, while Vanilla Extract commonly uses theme contracts + theme classes. Both support multiple themes with full type safety.
:::

:::accordion-item{label="Is there any runtime cost?" icon="i-lucide-circle-help"}
The generated styles are static CSS. The only "runtime" work in either approach is optional variant selection helpers (e.g., recipe functions) which generally resolve to class names. Both approaches result in zero-runtime theme switching.
:::

:::accordion-item{label="Can I mix global styles and per-component styles?" icon="i-lucide-circle-help"}
Yes. Both ecosystems can support a global entry stylesheet plus component-level extracted styles, depending on your build setup and how you organize modules. Styleframe supports a single global config, multiple per-component files, or a mix of both.
:::

:::accordion-item{label="Which has better tooling and framework support?" icon="i-lucide-circle-help"}
Vanilla Extract currently has an edge in documented compatibility with a broad range of tools due to its maturity. Styleframe is rapidly catching up - it was designed to be agnostic and already works with many frameworks. Styleframe focuses on Vite (the modern standard) and uses "unplugin" technology to support multiple bundlers.
:::

:::accordion-item{label="Which is better for a large team?" icon="i-lucide-circle-help"}
Styleframe is generally better suited for large teams due to its convention-driven approach, IDE integration, and built-in patterns that enforce consistency. New contributors can leverage the self-documenting API and see clearly defined patterns, leading to fewer styling bugs and a gentler learning curve.
:::

::
