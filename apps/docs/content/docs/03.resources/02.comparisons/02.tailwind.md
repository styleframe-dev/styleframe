---
title: Styleframe vs. Tailwind CSS
description: Compare Styleframe's type-safe design system approach with Tailwind CSS v4's utility-first CSS framework.
navigation:
  icon: i-simple-icons-tailwindcss
---

## Overview

Both **Styleframe** and **Tailwind CSS** follow a utility-first approach to styling, but they differ significantly in their implementation philosophy.

- **Styleframe**: a type-safe CSS API focused on design system primitives (tokens, themes, utilities, recipes) with TypeScript-native configuration.
- **Tailwind CSS**: a utility-first CSS framework with predefined classes and CSS-first configuration (v4) or JavaScript config (v3).

Both generate **static CSS at build time** with zero runtime cost. The key difference is how you define and organize your design system.

::tip
If your primary goal is **a scalable, type-safe design system** with programmatic token generation and consistent patterns across a team, Styleframe tends to require less external tooling than a Tailwind + CVA setup.
::

## At a glance

| Area | Styleframe | Tailwind CSS |
|------|------------|--------------|
| Core philosophy | Design system framework (tokens + patterns) | Utility-first CSS framework |
| Configuration | TypeScript-native | CSS-first (`@theme`) or JS config |
| Type safety | Full compile-time checking | IDE plugins (optional) |
| Tokens | Built-in `variable()` + composables | CSS custom properties via `@theme` |
| Variants | Built-in `recipe()` | External tools (CVA, Tailwind Variants) |
| Utilities | Programmatic `utility()` API | Predefined + `@utility` extensions |
| Class naming | Semantic, customizable (`_property:value`) | Terse, predefined (`bg-blue-500`) |
| Best for | Large design systems, multi-team consistency | Rapid prototyping, familiar workflow |

## Key differences

### Developer experience

#### Styleframe

- **Type-safe CSS API**: all style rules are written in TypeScript, providing auto-completion and compile-time error checking for CSS properties and values.
- **Convention-driven**: design tokens, themes, variants, and utilities share one mental model with dedicated APIs.
- **Explicit organization**: you define style classes in `styleframe.config.ts` and CSS selectors in a structured way.

#### Tailwind CSS

- **Utility classes in HTML**: developers apply many CSS classes (utilities) directly in HTML elements.
- **CSS-first configuration** (v4): define tokens using the `@theme` directive in CSS, with automatic utility generation.
- **Rapid iteration**: edit styles directly in markup without switching files; changes are immediately visible.

### Type safety and reliability

Both approaches aim for reliability, but they achieve it differently.

- Styleframe emphasizes **TypeScript validation** of token references (`variable()` + `ref()`) and utility definitions at compile time. Mistyped styles cause TypeScript errors before the app runs.
- Tailwind relies on **IDE plugins** (Tailwind CSS IntelliSense) for autocomplete and validation. Class names are strings, so typos won't cause build errors but will silently fail.

### Class naming and syntax

The frameworks take opposite approaches to class naming:

::tabs
:::tabs-item{icon="i-simple-icons-tailwindcss" label="Tailwind CSS"}

```html
<!-- Tailwind: terse, predefined class names -->
<button class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
  Save Changes
</button>
```

Each class (e.g., `px-4`, `bg-blue-500`, `rounded-md`, `hover:bg-blue-600`) corresponds to a single CSS declaration or rule. Tailwind comes with a huge set of predefined utility classes covering color, spacing, typography, layout, etc.

:::
:::tabs-item{icon="i-lucide-code" label="Styleframe"}

```html
<!-- Styleframe: semantic, customizable class names -->
<button class="button button--color-primary button--size-md">
  Save Changes
</button>
```

Styleframe generates class names based on your design system. You define the styles and classes you need using its TypeScript API, creating semantic names tailored to your project.

:::
::

::note
Tailwind's class naming is terse and systematic (e.g., `pt-4` for `padding-top`, `text-xl` for font size), whereas Styleframe's generated class names tend to be more verbose unless customized. Tailwind uses a pre-defined default color palette based on Oklab/OKLCH colors, while Styleframe encourages semantic naming for everything (once you define the tokens), making redesigns and theme adjustments safer and more consistent.
::

### API design and organization

#### Styleframe: "design system primitives"

Styleframe structures systems around reusable building blocks:

- **Variables**: define tokens once, reference everywhere with `ref()`.
- **Composables**: bundle related tokens/selectors/utilities into reusable modules.
- **Recipes**: model component variants with a type-safe runtime selector that outputs class names.
- **Utilities**: programmatically generate atomic utility classes.

#### Tailwind CSS: "utilities + configuration"

Tailwind's core is a comprehensive set of predefined utilities. Over time, teams often add:

- `@theme` configuration for custom tokens,
- CVA or Tailwind Variants for component variants,
- custom utilities via `@utility` directive,
- conventions for organizing Tailwind usage across components.

::note
If your goal is *"one coherent toolkit"* across tokens + themes + variants, Styleframe typically reduces the number of separate packages you need to adopt.
::

## Feature deep dive

### Tokens and variables

Both frameworks recognize the importance of design tokens, but they handle them differently.

#### Tailwind CSS v4

Tailwind v4 uses CSS custom properties via the `@theme` directive:

```css
/* Tailwind v4 - all theme values become CSS variables */
@theme {
  --color-primary: #006cff;
  --color-primary-dark: #0052cc;
  --spacing-md: 1rem;
}
```

All theme values are automatically published as CSS custom properties (e.g., `--color-primary`) on the `:root`, making them accessible globally in custom CSS or inline styles.

#### Styleframe

Styleframe treats tokens as first-class TypeScript values:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, selector } = s;

const colorPrimary = variable("color.primary", "#006cff");
const colorPrimaryDark = variable("color.primary.dark", "#0052cc");
const spacingMd = variable("spacing.md", "1rem");

selector(".button", {
  backgroundColor: ref(colorPrimary),
  padding: ref(spacingMd),
  "&:hover": {
    backgroundColor: ref(colorPrimaryDark),
  },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
  --color--primary: #006cff;
  --color--primary--dark: #0052cc;
  --spacing--md: 1rem;
}

.button {
  background-color: var(--color--primary);
  padding: var(--spacing--md);
}

.button:hover {
  background-color: var(--color--primary--dark);
}
```

:::
::

### Composables and reuse

Styleframe composables are a first-class pattern for packaging design system pieces into reusable modules:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";
import { useColor, useColorLightness, useSpacing } from "@styleframe/theme";

const s = styleframe();

// Generate a full color palette from a single base color
const { colorPrimary } = useColor(s, { primary: "#006cff" } as const);

// Automatically generate 11 lightness variants using OKLCH color space
const { colorPrimary50, colorPrimary500, colorPrimary900 } = useColorLightness(s, colorPrimary);

// Define spacing tokens
const { spacingSm, spacingMd, spacingLg } = useSpacing(s, {
  sm: "0.5rem",
  md: "1rem",
  lg: "1.5rem",
} as const);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
  --color--primary: #006cff;
  --color--primary--50: oklch(97% 0.03 264);
  --color--primary--500: oklch(55% 0.18 264);
  --color--primary--900: oklch(25% 0.18 264);
  --spacing--sm: 0.5rem;
  --spacing--md: 1rem;
  --spacing--lg: 1.5rem;
}
```

:::
::

This modular approach makes it easier to **share and reuse design system pieces** across projects.

### Variants and component recipes

Both ecosystems support component variants, but Styleframe ships recipes as part of the core toolkit.

#### Tailwind CSS with CVA

```tsx
// Tailwind + CVA (external dependency)
import { cva } from "class-variance-authority";

const button = cva("px-4 py-2 rounded font-medium", {
  variants: {
    color: {
      primary: "bg-blue-500 text-white hover:bg-blue-600",
      secondary: "bg-gray-200 text-gray-800 hover:bg-gray-300",
    },
    size: {
      sm: "text-sm px-3 py-1",
      lg: "text-lg px-6 py-3",
    },
  },
  defaultVariants: { color: "primary", size: "sm" },
});
```

#### Styleframe Recipes

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, recipe } = s;

const colorPrimary = variable("color.primary", "#006cff");
const colorPrimaryDark = variable("color.primary.dark", "#0052cc");
const colorWhite = variable("color.white", "#ffffff");

recipe({
  name: "button",
  base: {
    borderRadius: "0.375rem",
    fontWeight: 500,
  },
  variants: {
    color: {
      primary: {
        background: ref(colorPrimary),
        color: ref(colorWhite),
        "&:hover": { background: ref(colorPrimaryDark) },
      },
    },
    size: {
      sm: { fontSize: "0.875rem", padding: "0.5rem 0.75rem" },
      lg: { fontSize: "1.125rem", padding: "1rem 1.5rem" },
    },
  },
  defaultVariants: { color: "primary", size: "sm" },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.button {
  border-radius: 0.375rem;
  font-weight: 500;
}

.button--color-primary {
  background: var(--color--primary);
  color: var(--color--white);
}

.button--color-primary:hover {
  background: var(--color--primary--dark);
}

.button--size-sm {
  font-size: 0.875rem;
  padding: 0.5rem 0.75rem;
}

.button--size-lg {
  font-size: 1.125rem;
  padding: 1rem 1.5rem;
}
```

:::
::

### Theming (light/dark modes and beyond)

Both frameworks support theming, but handle it differently.

- **Tailwind CSS**: supports theming primarily through its "media" or "class" strategy for dark mode and custom variants. You typically set `darkMode` in config, then use utility variants like `dark:bg-gray-800`.
- **Styleframe**: has **native theming support** built into its API. You can define multiple themes and toggle them with a class or `[data-theme]` attribute. Defining a theme variant is as straightforward as defining the default.

::tabs
:::tabs-item{icon="i-lucide-code" label="Styleframe theming"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, theme } = s;

const colorPrimary = variable("color.primary", "#006cff");
const colorBackground = variable("color.background", "#ffffff");

// Override variables for dark theme
theme("dark", (ctx) => {
  ctx.variable(colorPrimary, "#60a5fa");
  ctx.variable(colorBackground, "#1a1a1a");
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
  --color--primary: #006cff;
  --color--background: #ffffff;
}

[data-theme="dark"] {
  --color--primary: #60a5fa;
  --color--background: #1a1a1a;
}
```

:::
::

### SSR and performance

Both are zero-runtime on the client:

- CSS is extracted at build time.
- SSR/SSG frameworks can serve HTML with classes already applied and CSS already linked/loaded.
- Tailwind v4 has significantly improved build performance with its new Rust-based engine.
- Styleframe's compilation is comparable to adding a TypeScript build step.

## Choosing between them

### Choose Styleframe if…

- You're building a **large-scale design system** or UI library that needs to be stable, type-safe, and shared.
- You want **organized, explicit CSS** with abstraction of design decisions (tokens, recipes) that can be shared.
- You're building a design system that spans multiple frameworks (React, Vue, etc.) or needs a core design language used across projects.
- **Type safety and compile-time validation** are important to your team.
- You expect many contributors and want conventions to be discoverable and enforced.

### Choose Tailwind CSS if…

- Your goal is to **move fast in a single project** and you prefer styling in the markup with quick iterations.
- Your team is already **familiar with Tailwind** and its ecosystem.
- You need **extensive community resources** and ready-made solutions for common problems.
- **Design consistency is needed but strict enforcement is not critical** – Tailwind provides a flexible yet coherent system.
- You're optimizing for rapid development and established workflows.

::tip
A practical heuristic: if visual consistency is critical (banks, large enterprise apps), Styleframe's guarantees can outweigh the convenience of on-the-fly utility classes. For fast-moving projects where the team already knows Tailwind, Tailwind v4 offers a balanced mix of productivity and design system capabilities.
::

## FAQ

::accordion

:::accordion-item{label="Do both approaches support theming (light/dark, brand themes)?" icon="i-lucide-circle-help"}
Yes. Both compile themes to CSS variables scoped by a class/attribute. Styleframe provides a dedicated theming API integrated with variables, while Tailwind uses `darkMode` configuration and utility variants.
:::

:::accordion-item{label="Is there any runtime cost?" icon="i-lucide-circle-help"}
The generated styles are static CSS. The only "runtime" work in either approach is optional variant selection helpers (e.g., recipe functions or CVA) which resolve to class name strings.
:::

:::accordion-item{label="Can I use Styleframe composables to match Tailwind's development speed?" icon="i-lucide-circle-help"}
Yes. Styleframe provides pre-made composables from `@styleframe/theme` (e.g., `useColor`, `useSpacing`, `useFontSize`, `useUtilities`) that provide ready-to-use design tokens and utility generators. You can start with these for rapid development, then customize as your design system evolves.
:::

:::accordion-item{label="Which has better IDE support?" icon="i-lucide-circle-help"}
Tailwind has excellent IDE support through the Tailwind CSS IntelliSense extension, providing autocomplete for class names in HTML. Styleframe provides native TypeScript autocomplete and type checking in your config file, catching errors at compile time rather than relying on IDE plugins.
:::

:::accordion-item{label="Can I migrate from Tailwind to Styleframe?" icon="i-lucide-circle-help"}
Yes, but it requires rethinking your approach. Tailwind's utility classes are scattered in HTML, while Styleframe centralizes style definitions. You would define your design tokens and utilities in Styleframe, then update your markup to use the generated class names or recipes.
:::

::
