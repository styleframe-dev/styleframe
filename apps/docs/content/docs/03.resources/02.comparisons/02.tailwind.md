---
title: Styleframe vs Tailwind CSS
description: A technical comparison of Styleframe and Tailwind CSS utility systems, covering type safety, design tokens, customization, and developer experience.
navigation: false
---

Both Styleframe and Tailwind CSS follow a utility-first approach to styling, but they differ significantly in their implementation philosophy. Tailwind CSS generates utility classes from configuration, while Styleframe provides a programmatic, type-safe TypeScript API for creating utilities and design systems.

This comparison examines how each framework handles common styling challenges and highlights where each approach excels.

## Quick Comparison

| Feature | Styleframe | Tailwind CSS |
|---------|------------|--------------|
| **Type Safety** | Full TypeScript, compile-time | IDE plugins (optional) |
| **Design Tokens** | TypeScript composables | CSS `@theme` or JS config |
| **Utility Definition** | Programmatic with `utility()` | Predefined + extensions |
| **Modifiers** | Custom JavaScript logic | Built-in set |
| **Component Variants** | Built-in `recipe()` system | External tools (CVA) |
| **Runtime Cost** | Zero | Zero |
| **Class Format** | `_property:value` | `property-value` |

## Type Safety

### Tailwind CSS

Tailwind configuration uses JavaScript or CSS, with optional TypeScript support for the config file:

```js
// tailwind.config.js - No type checking by default
module.exports = {
    theme: {
        extend: {
            colors: {
                primary: '#006cff',
            },
        },
    },
};
```

While Tailwind v4 supports TypeScript config files, the utilities themselves are still string-based in your HTML/JSX.

### Styleframe

Styleframe configuration is TypeScript-native, providing type checking for utility definitions and design tokens:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, utility } = s;

const colorPrimary = variable("color.primary", "#006cff");

const createBackgroundUtility = utility("background", ({ value }) => ({
    background: value,
}));

// TypeScript validates that ref() references exist
createBackgroundUtility({
    primary: ref(colorPrimary),
    white: "#ffffff",
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--primary: #006cff;
}

._background\:primary {
    background: var(--color--primary);
}

._background\:white {
    background: #ffffff;
}
```

:::
::

TypeScript validates variable references and utility definitions at compile time, catching errors before they reach production.

## Design Token Management

### Tailwind CSS

Tailwind v4 uses a CSS-first approach with the `@theme` directive:

```css
/* Tailwind v4 - CSS-based configuration */
@theme {
    --color-primary: #006cff;
    --color-primary-dark: #0052cc;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
}
```

For more complex logic, you need JavaScript configuration (v3 style):

```js
// tailwind.config.js
module.exports = {
    theme: {
        extend: {
            colors: {
                primary: '#006cff',
                'primary-dark': '#0052cc',
            },
            spacing: {
                sm: '0.5rem',
                md: '1rem',
                lg: '1.5rem',
            },
        },
    },
};
```

### Styleframe

Styleframe defines the same tokens using TypeScript:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable } = s;

// Define color tokens
const colorPrimary = variable("color.primary", "#006cff");
const colorPrimaryDark = variable("color.primary.dark", "#0052cc");

// Define spacing tokens
const spacingSm = variable("spacing.sm", "0.5rem");
const spacingMd = variable("spacing.md", "1rem");
const spacingLg = variable("spacing.lg", "1.5rem");

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--primary: #006cff;
    --color--primary--dark: #0052cc;
    --spacing--sm: 0.5rem;
    --spacing--md: 1rem;
    --spacing--lg: 1.5rem;
}
```

:::
::

For larger design systems, Styleframe provides composables that generate tokens programmatically:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";
import { useColor, useColorShade } from "@styleframe/theme";

const s = styleframe();
const { variable } = s;

// Generate color with automatic darker variant
const { colorPrimary } = useColor(s, { primary: "#006cff" } as const);
const { colorPrimaryShade100 } = useColorShade(s, colorPrimary, { 100: 10 } as const);

// Define spacing tokens
const spacingSm = variable("spacing.sm", "0.5rem");
const spacingMd = variable("spacing.md", "1rem");
const spacingLg = variable("spacing.lg", "1.5rem");

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
:root {
    --color--primary: #006cff;
    --color--primary--shade--100: oklch(0.45 0.18 264);
    --spacing--sm: 0.5rem;
    --spacing--md: 1rem;
    --spacing--lg: 1.5rem;
}
```

:::
::

Key differences:
- **Programmatic generation**: Use composables to generate color variants, scales, and more
- **OKLCH color space**: Perceptually uniform colors for consistent lightness across hues
- **TypeScript-native**: Full autocomplete and type checking for token definitions

## Utility Definition

### Tailwind CSS

Tailwind provides a comprehensive set of predefined utilities. Custom utilities require CSS:

```css
/* Adding custom utilities in Tailwind v4 */
@utility content-auto {
    content-visibility: auto;
}

/* Functional utility with values */
@utility tab-* {
    tab-size: --value(--tab-size-*);
}
```

### Styleframe

Styleframe utilities are created programmatically with full control over the generated CSS:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, utility, css } = s;

// Create a grid span utility that generates complex CSS
const createGridColumnUtility = utility("grid-column", ({ value }) => ({
    gridColumn: css`span ${value} / span ${value}`,
}));

// Pre-generate utility classes programmatically
// (Styleframe also supports auto-generation from design token arrays)
const gridSpans = {};
for (let i = 1; i <= 12; i++) {
    gridSpans[i] = i;
}
gridSpans["full"] = "1 / -1";

createGridColumnUtility(gridSpans);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
._grid-column\:1 {
    grid-column: span 1 / span 1;
}
._grid-column\:2 {
    grid-column: span 2 / span 2;
}
/* ... */
._grid-column\:12 {
    grid-column: span 12 / span 12;
}
._grid-column\:full {
    grid-column: 1 / -1;
}
```

:::
::

## Modifiers

### Tailwind CSS

Tailwind includes a fixed set of modifiers for states and responsive design:

```html
<!-- Tailwind modifiers -->
<button class="bg-blue-500 hover:bg-blue-600 focus:ring-2 md:px-6 dark:bg-blue-400">
  Button
</button>
```

Custom variants require the `@custom-variant` directive:

```css
@custom-variant theme-midnight {
    &:where([data-theme="midnight"] *) {
        @slot;
    }
}
```

### Styleframe

Styleframe modifiers are JavaScript functions with full control over the transformation. Here's how to create the same button styling:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe, valueOf } from "styleframe";
import { useBreakpoint } from "@styleframe/theme";

const s = styleframe();
const { variable, ref, utility, modifier } = s;

// Define the same colors as the Tailwind example
const colorBlue500 = variable("color.blue.500", "#3b82f6");
const colorBlue600 = variable("color.blue.600", "#2563eb");
const colorBlue400 = variable("color.blue.400", "#60a5fa");

// State modifiers
const hover = modifier("hover", ({ declarations }) => ({
    "&:hover": declarations,
}));

const focus = modifier("focus", ({ declarations }) => ({
    "&:focus": declarations,
}));

// Media query modifier for dark mode
const dark = modifier("dark", ({ declarations }) => ({
    "@media (prefers-color-scheme: dark)": declarations,
}));

// Responsive modifier
const { breakpointMd } = useBreakpoint(s);

const md = modifier("md", ({ declarations }) => ({
    [`@media (min-width: ${valueOf(breakpointMd)})`]: declarations,
}));

// Create utilities with modifiers
const createBackgroundUtility = utility("background", ({ value }) => ({
    background: value,
}));

const createPaddingXUtility = utility("padding-x", ({ value }) => ({
    paddingLeft: value,
    paddingRight: value,
}));

const createRingUtility = utility("ring", ({ value }) => ({
    boxShadow: `0 0 0 ${value} currentColor`,
}));

createBackgroundUtility(
    { "blue-500": ref(colorBlue500), "blue-600": ref(colorBlue600), "blue-400": ref(colorBlue400) },
    [hover, dark]
);

createPaddingXUtility({ 6: "1.5rem" }, [md]);

createRingUtility({ 2: "2px" }, [focus]);

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
/* Background utilities */
._background\:blue-500 {
    background: var(--color--blue--500);
}

._hover\:background\:blue-600 {
    &:hover {
        background: var(--color--blue--600);
    }
}

._dark\:background\:blue-400 {
    @media (prefers-color-scheme: dark) {
        background: var(--color--blue--400);
    }
}

/* Focus ring utility */
._focus\:ring\:2 {
    &:focus {
        box-shadow: 0 0 0 2px currentColor;
    }
}

/* Responsive padding utility */
._md\:padding-x\:6 {
    @media (min-width: 992px) {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }
}
```

:::
::

Usage in HTML (equivalent to the Tailwind example):

```html
<button class="_background:blue-500 _hover:background:blue-600 _focus:ring:2 _md:padding-x:6 _dark:background:blue-400">
  Button
</button>
```

## Component Variants (Recipes)

### Tailwind CSS with CVA

Tailwind requires external libraries like CVA (Class Variance Authority) for component variants:

```tsx
// Tailwind + CVA
import { cva } from "class-variance-authority";

const button = cva("px-4 py-2 rounded font-medium", {
    variants: {
        color: {
            primary: "bg-blue-500 text-white hover:bg-blue-600",
            secondary: "bg-gray-200 text-gray-800 hover:bg-gray-300",
        },
        size: {
            sm: "text-sm px-3 py-1",
            md: "text-base px-4 py-2",
            lg: "text-lg px-6 py-3",
        },
    },
    defaultVariants: {
        color: "primary",
        size: "md",
    },
});

// Usage
<button className={button({ color: "primary", size: "lg" })}>Click me</button>
```

### Styleframe Recipes

Styleframe includes a built-in recipe system with full type safety:

::tabs
:::tabs-item{icon="i-lucide-code" label="Code"}

```ts [styleframe.config.ts]
import { styleframe } from "styleframe";

const s = styleframe();
const { variable, ref, recipe, css } = s;

const colorPrimary = variable("color.primary", "#006cff");
const colorPrimaryDark = variable("color.primary.dark", "#0052cc");
const colorSecondary = variable("color.secondary", "#6c757d");
const colorWhite = variable("color.white", "#ffffff");

const spacingSm = variable("spacing.sm", "0.5rem");
const spacingMd = variable("spacing.md", "1rem");
const spacingLg = variable("spacing.lg", "1.5rem");

recipe({
    name: "button",
    base: {
        borderRadius: "0.375rem",
        fontWeight: 500,
        transition: "background-color 150ms ease",
    },
    variants: {
        color: {
            primary: {
                background: ref(colorPrimary),
                color: ref(colorWhite),
                "&:hover": {
                    background: ref(colorPrimaryDark),
                },
            },
            secondary: {
                background: ref(colorSecondary),
                color: ref(colorWhite),
            },
        },
        size: {
            sm: {
                fontSize: "0.875rem",
                padding: css`${ref(spacingSm)} calc(${ref(spacingSm)} * 1.5)`,
            },
            md: {
                fontSize: "1rem",
                padding: css`${ref(spacingMd)} calc(${ref(spacingMd)} * 1.5)`,
            },
            lg: {
                fontSize: "1.125rem",
                padding: css`${ref(spacingLg)} calc(${ref(spacingLg)} * 1.5)`,
            },
        },
    },
    defaultVariants: {
        color: "primary",
        size: "md",
    },
});

export default s;
```

:::
:::tabs-item{icon="i-lucide-file-input" label="Output"}

```css [styleframe/index.css]
.button {
    border-radius: 0.375rem;
    font-weight: 500;
    transition: background-color 150ms ease;
}

.button--color-primary {
    background: var(--color--primary);
    color: var(--color--white);
}

.button--color-primary:hover {
    background: var(--color--primary--dark);
}

.button--color-secondary {
    background: var(--color--secondary);
    color: var(--color--white);
}

.button--size-sm {
    font-size: 0.875rem;
    padding: var(--spacing--sm) calc(var(--spacing--sm) * 1.5);
}

.button--size-md {
    font-size: 1rem;
    padding: var(--spacing--md) calc(var(--spacing--md) * 1.5);
}

.button--size-lg {
    font-size: 1.125rem;
    padding: var(--spacing--lg) calc(var(--spacing--lg) * 1.5);
}
```

:::
::

Runtime usage with type safety:

```tsx
import { button } from "virtual:styleframe";

// Full autocomplete and type checking
<button className={button({ color: "primary", size: "lg" })}>
  Click me
</button>

// TypeScript error: "purple" is not assignable to "primary" | "secondary"
<button className={button({ color: "purple" })}>Invalid</button>
```

## When to Choose Each

### Choose Tailwind CSS when:

- Your team is already familiar with Tailwind
- You need extensive community resources and examples
- The project doesn't require complex design system management
- You prefer CSS-first configuration

### Choose Styleframe when:

- **Type safety** is critical to your workflow
- You're building a **design system** that will be maintained long-term
- You need **programmatic token generation** (color palettes, scales, fluid values)
- Your team prefers **TypeScript-native** tooling
- You want **built-in component variants** without external dependencies
- You need **custom modifiers** with complex logic
- **Perceptually uniform colors** (OKLCH) are important for your design

## Summary

Both Tailwind CSS and Styleframe are capable utility-first frameworks with zero runtime cost. Tailwind is known for rapid development with its extensive predefined utilities and large community.

Styleframe achieves comparable development speed through pre-made composables from `@styleframe/theme`. Functions like `useColor`, `useSpacing`, `useFontSize`, and `useUtilities` provide ready-to-use design tokens and utility generatorsâ€”similar to Tailwind's predefined classes, but with full TypeScript support and programmatic customization. You can start with the pre-made composables for rapid development, then customize as your design system evolves.

The choice depends on your project's needs: Tailwind for familiarity and community resources, Styleframe for type safety and scalable design systems.
